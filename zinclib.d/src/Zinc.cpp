/**       Zinc.cpp
 *      zinclib
 *
 *   This software is the property of IntuiLab SA, France.
 *   All rights reserved.
 *
 *   Redistribution and use in source and binary forms, with or without
 *   modification, are permitted provided that the following conditions
 *   are met:
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *   3. The name of the author may not be used to endorse or promote products
 *      derived from this software without specific prior written permission.
 * 
 *   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 *   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 *   Here is the definition of the Zinc object
 *
 *      08/03/05
 *
 *      Contributors:
 *           Benoit Peccatte <peccatte@intuilab.com>
 *           David Thevenin <thevenin@intuilab.com>
 *
 */
#include "Zinc.hpp"
#include "ZincInternal.hpp"
#include <iostream>
#include <sstream>
#include <tk.h>

/**
 * How To call Zinc or Tcl functions:
 *
 * All arguments of the function are Tcl_Obj. To accelerate their call, there
 * is a pool of preconstructed Tcl_Obj and some often used constant Tcl_Obj.
 * p1 and p2 are tables of pointers to be used for arguments.
 * Fill p1 using either predefined objects like ZITM_* or a pool objet that
 * you can fill with the value you want.
 *  Ex : p1[1] = ZFCT_add;
 * Macros have been defined to fill and use a pool object
 *  Ex : p1[2] = Z_INT_POOL (1, 200);
 * Do not use twice the same pool index for the same function call.
 * p2 is used to construct and argument which is a list of Tcl_Obj.
 * To call the function use z_tcl_call which automaticly handle error return
 * codes or z_command to call a Zinc command which handle all arguments too.
 */

//predeclare private function
#ifdef _WIN32
int __cdecl tclCallback (ClientData client_data, Tcl_Interp *interp,
                  int argc, Tcl_Obj *CONST args[]);
#else
int tclCallback (ClientData client_data, Tcl_Interp *interp,
                  int argc, Tcl_Obj *CONST args[]) __attribute__((cdecl));
#endif

/*******************************************************
                     ZINC OBJECT
*******************************************************/


int Zinc::znCount = 0;               ///< count to create unique ids
Tcl_Interp *Zinc::interp;            ///< the tcl interpreter
Tcl_CmdInfo Zinc::topCmdInfo;       ///< the command associated with toplevel
Tcl_CmdInfo Zinc::zncCmdInfo;       ///< the command associated with zinc
Tcl_CmdInfo Zinc::imgCmdInfo;       ///< the command associated with image
Tcl_CmdInfo Zinc::fntCmdInfo;       ///< the command associated with font
Tcl_CmdInfo Zinc::focCmdInfo;       ///< the command associated with focus
Tcl_CmdInfo Zinc::bndCmdInfo;       ///< the command associated with bind
Tcl_Obj* Zinc::pool[ZINC_POOL_COUNT];///<  a pool of tclobj ready to be used
Tcl_Obj* Zinc::p1[ZINC_PARAM_COUNT]; ///<  a table of pointeurs use for parameters
Tcl_Obj* Zinc::p2[ZINC_PARAM_COUNT]; ///<  a table of pointeurs use for parameters

static Tcl_Obj *DEFAULT_GROUP_OBJ = Tcl_NewIntObj (DEFAULT_GROUP);

//option constants
//Tcl_Obj* Z_render = Tcl_NewStringObj ("-render", -1);
Z_DEFINE_ZOPT (render);             ///< the "-render" option
Z_DEFINE_ZOPT (firstend);           ///< the "-firstend" option
Z_DEFINE_ZOPT (lastend);            ///< the "-lastend" option
Z_DEFINE_ZOPT (position);           ///< the "-position" option
Z_DEFINE_ZOPT (tags);               ///< the "-tags" option
Z_DEFINE_ZOPT (backcolor);          ///< the "-backcolor" option
Z_DEFINE_ZOPT (forecolor);          ///< the "-forecolor" option
Z_DEFINE_ZOPT (height);             ///< the "-height" option
Z_DEFINE_ZOPT (borderwidth);        ///< the "-borderwidth" option


//autogenerated constants
Z_DEFINE_ZOPT (closed);            ///< the "-closed" option
Z_DEFINE_ZOPT (composealpha);      ///< the "-composealpha" option
Z_DEFINE_ZOPT (composerotation);   ///< the "-composerotation" option
Z_DEFINE_ZOPT (composescale);      ///< the "-composescale" option
Z_DEFINE_ZOPT (extent);            ///< the "-extent" option
Z_DEFINE_ZOPT (fillcolor);         ///< the "-fillcolor" option
Z_DEFINE_ZOPT (filled);            ///< the "-filled" option
Z_DEFINE_ZOPT (fillpattern);       ///< the "-fillpattern" option
Z_DEFINE_ZOPT (linecolor);         ///< the "-linecolor" option
Z_DEFINE_ZOPT (linepattern);       ///< the "-linepattern" option
Z_DEFINE_ZOPT (linestyle);         ///< the "-linestyle" option
Z_DEFINE_ZOPT (linewidth);         ///< the "-linewidth" option
Z_DEFINE_ZOPT (pieslice);          ///< the "-pieslice" option
Z_DEFINE_ZOPT (priority);          ///< the "-priority" option
Z_DEFINE_ZOPT (sensitive);         ///< the "-sensitive" option
Z_DEFINE_ZOPT (startangle);        ///< the "-startangle" option
Z_DEFINE_ZOPT (tile);              ///< the "-tile" option
Z_DEFINE_ZOPT (visible);           ///< the "-visible" option
Z_DEFINE_ZOPT (capstyle);          ///< the "-capstyle" option
Z_DEFINE_ZOPT (fillrule);          ///< the "-fillrule" option
Z_DEFINE_ZOPT (joinstyle);         ///< the "-joinstyle" option
Z_DEFINE_ZOPT (marker);            ///< the "-marker" option
Z_DEFINE_ZOPT (markercolor);       ///< the "-markercolor" option
Z_DEFINE_ZOPT (relief);            ///< the "-relief" option
Z_DEFINE_ZOPT (smoothrelief);      ///< the "-smoothrelief" option
Z_DEFINE_ZOPT (alpha);             ///< the "-alpha" option
Z_DEFINE_ZOPT (atomic);            ///< the "-atomic" option
Z_DEFINE_ZOPT (clip);              ///< the "-clip" option
Z_DEFINE_ZOPT (anchor);            ///< the "-anchor" option
Z_DEFINE_ZOPT (color);             ///< the "-color" option
Z_DEFINE_ZOPT (connecteditem);     ///< the "-connecteditem" option
Z_DEFINE_ZOPT (connectionanchor);  ///< the "-connectionanchor" option
Z_DEFINE_ZOPT (image);             ///< the "-image" option
Z_DEFINE_ZOPT (mask);              ///< the "-mask" option
Z_DEFINE_ZOPT (alignment);         ///< the "-alignment" option
Z_DEFINE_ZOPT (font);              ///< the "-font" option
Z_DEFINE_ZOPT (overstriked);       ///< the "-overstriked" option
Z_DEFINE_ZOPT (spacing);           ///< the "-spacing" option
Z_DEFINE_ZOPT (text);              ///< the "-text" option
Z_DEFINE_ZOPT (underlined);        ///< the "-underlined" option
Z_DEFINE_ZOPT (width);             ///< the "-width" option

//other constants
Z_DEFINE_ZFCT (device);            ///< the "device" keyword

///< function constants
Z_DEFINE_ZFCT (add);           ///< the "add" function
Z_DEFINE_ZFCT (addtag);        ///< the "addtag" function
Z_DEFINE_ZFCT (bind);          ///< the "bind" function
Z_DEFINE_ZFCT (bbox);          ///< the "bbox" function
Z_DEFINE_ZFCT (cget);          ///< the "cget" function
Z_DEFINE_ZFCT (chggroup);      ///< the "chggroup" function
Z_DEFINE_ZFCT (clone);         ///< the "clone" function
Z_DEFINE_ZFCT (configure);     ///< the "configure" function
Z_DEFINE_ZFCT (contour);       ///< the "contour" function
Z_DEFINE_ZFCT (coords);        ///< the "coords" function
Z_DEFINE_ZFCT (dtag);          ///< the "dtag" function
Z_DEFINE_ZFCT (focus);         ///< the "focus" function
Z_DEFINE_ZFCT (gettags);       ///< the "gettags" function
Z_DEFINE_ZFCT (gname);         ///< the "gname" function
Z_DEFINE_ZFCT (group);         ///< the "group" function
Z_DEFINE_ZFCT (itemconfigure); ///< the "itemconfigure" function
Z_DEFINE_ZFCT (itemcget);      ///< the "itemcget" function
Z_DEFINE_ZFCT (lower);         ///< the "lower" function
Z_DEFINE_ZFCT (raise);         ///< the "raise" function
Z_DEFINE_ZFCT (remove);        ///< the "remove" function
Z_DEFINE_ZFCT (rotate);        ///< the "rotate" function
Z_DEFINE_ZFCT (scale);         ///< the "scale" function
Z_DEFINE_ZFCT (skew);          ///< the "skew" function
Z_DEFINE_ZFCT (tget);          ///< the "tget" function
Z_DEFINE_ZFCT (translate);     ///< the "translate" function
Z_DEFINE_ZFCT (transform);     ///< the "transform" function
Z_DEFINE_ZFCT (treset);        ///< the "treset" function
Z_DEFINE_ZFCT (tset);          ///< the "tset" function
Z_DEFINE_ZFCT (type);          ///< the "type" function

//Item constants
Z_DEFINE_ZITM (add);           ///< the "add" constant
Z_DEFINE_ZITM (arc);           ///< the "arc" constant
Z_DEFINE_ZITM (curve);         ///< the "curve" constant
Z_DEFINE_ZITM (icon);          ///< the "icon" constant
Z_DEFINE_ZITM (group);         ///< the "group" constant
Z_DEFINE_ZITM (rectangle);     ///< the "rectangle" constant
Z_DEFINE_ZITM (text);          ///< the "text" constant
Z_DEFINE_ZITM (withtag);       ///< the "withtag" constant

/*********************************************
           Prepare enum Tcl_Obj
*********************************************/

//lineStyles strings
const char* lineStylesStrings [] =
{ "simple", "dashed", "mixed", "dotted" };
//lineStyles Tcl_Obj
Tcl_Obj* lineStyles [] =
{
  Tcl_NewStringObj ("simple", -1),
  Tcl_NewStringObj ("dashed", -1),
  Tcl_NewStringObj ("mixed", -1),
  Tcl_NewStringObj ("dotted", -1),
};

//capStyles strings
const char* capStylesStrings [] =
{ "butt", "projecting", "round" };
//capStyles Tcl_Obj
Tcl_Obj* capStyles [] =
{
  Tcl_NewStringObj ("butt", -1),
  Tcl_NewStringObj ("projecting", -1),
  Tcl_NewStringObj ("round", -1),
};

// fillRules strings
const char* fillRulesStrings [] =
{ "odd", "nonzero", "positive", "negative", "abs_geq_2" };
//fillRules Tcl_Obj
Tcl_Obj* fillRules [] =
{
  Tcl_NewStringObj ("odd", -1),
  Tcl_NewStringObj ("nonzero", -1),
  Tcl_NewStringObj ("positive", -1),
  Tcl_NewStringObj ("negative", -1),
  Tcl_NewStringObj ("abs_geq_2", -1),
};

// joinStyle strings
const char* joinStylesStrings [] =
{ "bevel", "miter", "round" };
// joinStyles Tcl_Obj
Tcl_Obj* joinStyles [] =
{
  Tcl_NewStringObj ("bevel", -1),
  Tcl_NewStringObj ("miter", -1),
  Tcl_NewStringObj ("round", -1),
};

// reliefs strings
const char* reliefsStrings [] =
{ "flat", "raised", "sunken", "ridge", "groove", "roundraised",
  "roundsunken", "roundridge", "roundgroove", "raisedrule", "sunkenrule" };
// reliefs Tcl_Obj
Tcl_Obj* reliefs [] =
{
  Tcl_NewStringObj ("flat", -1),
  Tcl_NewStringObj ("raised", -1),
  Tcl_NewStringObj ("sunken", -1),
  Tcl_NewStringObj ("ridge", -1),
  Tcl_NewStringObj ("groove", -1),
  Tcl_NewStringObj ("roundraised", -1),
  Tcl_NewStringObj ("roundsunken", -1),
  Tcl_NewStringObj ("roundridge", -1),
  Tcl_NewStringObj ("roundgroove", -1),
  Tcl_NewStringObj ("raisedrule", -1),
  Tcl_NewStringObj ("sunkenrule", -1),
};

// alignments strings
const char* alignmentsStrings [] =
{ "left", "right", "center" };
// alignments Tcl_obj
Tcl_Obj* alignments [] =
{
  Tcl_NewStringObj ("left", -1),
  Tcl_NewStringObj ("right", -1),
  Tcl_NewStringObj ("center", -1),
};

// anchors strings
const char* anchorsStrings [] =
{ "nw", "n", "ne", "e", "se", "s", "sw", "w", "center" };
// anchors Tcl_Obj
Tcl_Obj* anchors [] =
{
  Tcl_NewStringObj ("nw", -1),
  Tcl_NewStringObj ("n", -1),
  Tcl_NewStringObj ("ne", -1),
  Tcl_NewStringObj ("e", -1),
  Tcl_NewStringObj ("se", -1),
  Tcl_NewStringObj ("s", -1),
  Tcl_NewStringObj ("sw", -1),
  Tcl_NewStringObj ("w", -1),
  Tcl_NewStringObj ("center", -1),
};

// itemType strings
const char* itemTypeStrings [] =
{
  "group",
  "arc",
  "text",
  "rectangle",
  "curve",
  "icon",
  NULL
};
//no need for Tcl_Objs because they are only used as return values


/**********************************
         Zinc Object
**********************************/

/**
 * The public constructor
   *
   * @param renderingMode ZINC_BACKEND_X11 or ZINC_BACKEND_OPENGL
 */
Zinc::Zinc (int renderingMode)
{
  String theId;

  //preparating id (.zn and a unique number)
  znCount++;
  theId = ".zn";
  theId += itos(znCount);
  window = ".";

  //create a new window for each other widget
  if (znCount != 1)
  {
    window  = ".zwin";
    window += itos (znCount);

    //create a new toplevel window
    const char* para[2];
    para[0] = "toplevel";
    para[1] = window.c_str();
    //call the toplevel Tk function with 2 arguments
    z_tcl_call ((*topCmdInfo.proc)(topCmdInfo.clientData, interp, 2, para),
                "toplevel Failed : ");

    //adapt the zinc id to the window path
    theId = window + theId;
  }

  //  String noResizeCommand = String ("wm resizable ") + window + " 0 0";
  //Tcl_Eval (interp, noResizeCommand.c_str ());

  //use a tcl_obj for the id
  id = Tcl_NewStringObj (theId.c_str (), theId.length ());
  Tcl_IncrRefCount (id);

  //get top windows for zinc widget
  Tk_Window top_w = Tk_MainWindow (interp);

  //creation of the zinc item
  //  call  "Zinc id -render mode
  Tcl_ResetResult (interp);
  p1[0] = NULL;
  p1[1] = id;
  p1[2] = ZOPT_render;
  p1[3] = Z_INT_POOL (0, renderingMode);
  // call the function with 4 arguments and check non error
  z_tcl_call ((*zncCmdInfo.objProc) (ClientData (top_w), interp, 4, p1),
               "ZincObjCmd failed :");

  // get back ZnWInfo *wi and WidgetObjCmd
  Tcl_CmdInfo cmdInfo;
  int result = Tcl_GetCommandInfo (interp, theId.c_str (), &cmdInfo);
  if (!result)
  {
    throw ZincException (String ("zinclib: Tcl command not found") +
                         Tcl_GetStringResult (interp), __FILE__, __LINE__);
  }

  //get informations necessary to call WidgetObjCmd
  wi = cmdInfo.objClientData;
  objCmd = (WidgetObjCmd)cmdInfo.objProc;

  //call the Tk function pack
  String packCmd = String ("pack ") + theId + " -expand 1 -fill both";
  Tcl_Eval (interp, packCmd.c_str ());

  // Prepare for binding with callback (create a Tcl function)
  tclCb = String (Z_TCLCB) + itos(znCount);
  Tcl_CreateObjCommand(interp, tclCb.c_str (), tclCallback,
                       (ClientData) this, (Tcl_CmdDeleteProc *) NULL);

  //give focus to the window
  const char* para[2];
  para[0] = "focus";
  para[1] = theId.c_str();
  // call the function with 4 arguments
  z_tcl_call ((*focCmdInfo.proc)(focCmdInfo.clientData, interp, 2, para),
              "focus Failed : ");
}

/**
 * The public destructor
 */
Zinc::~Zinc ()
{
  //delete the Tcl function
  Tcl_DeleteCommand (interp, tclCb.c_str ());
  // delete the tcl_obj
  Tcl_DecrRefCount (id);
}

/**
 * Change window title
 *
 * @param title the title string
 */
void Zinc::setTitle (String title)
{
  //use tcl interpreter directly since this won't be called often
  String command = String ("wm title ") + window + " \"" + title + "\"";
  Tcl_Eval (interp, command.c_str ());
}

/*****************************************
          WIDGET PROPERTIES
*****************************************/
/**
 * How To call Zinc or Tcl functions:
 *
 * All arguments of the function are Tcl_Obj. To accelerate their call, there
 * is a pool of preconstructed Tcl_Obj and some often used constant Tcl_Obj.
 * p1 and p2 are tables of pointers to be used for arguments.
 * Fill p1 using either predefined objects like ZITM_* or a pool objet that
 * you can fill with the value you want.
 *  Ex : p1[1] = ZFCT_add;
 * Macros have been defined to fill and use a pool object
 *  Ex : p1[2] = Z_INT_POOL(1, 200);
 * Do not use twice the same pool index for the same function call.
 * p2 is used to construct and argument which is a list of Tcl_Obj.
 * To call the function use z_tcl_call which automaticly handle error return
 * codes or z_command to call a Zinc command which handle all arguments too.
 */

/**
 * Call zinc->configure ( -backcolor )
 *
 * @param value the backcolor to set
 */
void Zinc::setBackcolor (String value)
{
  //call .zinc configure -backcolor value
  p1[0] = id;
  p1[1] = ZFCT_configure;
  p1[2] = ZOPT_backcolor;
  p1[3] = Z_STR_POOL (0, value.c_str(), value.length());
  // call the function with 4 arguments
  z_command (4, "setBackcolor Failed : ");
}

/**
 * Call zinc->cget ( -backcolor )
 *
 * @return backcolor value
 */
String Zinc::getBackcolor ()
{
  Tcl_Obj* tmp;
  //discard old results
  Tcl_ResetResult (interp);
  //call .zinc cget -backcolor
  p1[0] = id;
  p1[1] = ZFCT_cget;
  p1[2] = ZOPT_backcolor;
  // call the function with 3 arguments
  z_command (3, "getBackcolor Failed : ");

  //retreive the result as a string
  tmp = Tcl_GetObjResult (interp);
  return String (Tcl_GetStringFromObj (tmp, NULL));
}

/**
 * Call zinc->configure ( -forecolor )
 *
 * @param value the forecolor to set
 */
void Zinc::setForecolor (String value)
{
  //call .zinc configure -forecolor value
  p1[0] = id;
  p1[1] = ZFCT_configure;
  p1[2] = ZOPT_forecolor;
  p1[3] = Z_STR_POOL (0, value.c_str(), value.length());
  // call the function with 4 arguments
  z_command (4, "setForecolor Failed : ");
}

/**
 * Call zinc->cget ( -forecolor )
 *
 * @return forecolor value
 */
String Zinc::getForecolor ()
{
  Tcl_Obj* tmp;
  //discard old results
  Tcl_ResetResult (interp);
  //call .zinc cget -forecolor
  p1[0] = id;
  p1[1] = ZFCT_cget;
  p1[2] = ZOPT_forecolor;
  // call the function with 3 arguments
  z_command (3, "getForecolor Failed : ");

  //retreive the result as a string
  tmp = Tcl_GetObjResult (interp);
  return String (Tcl_GetStringFromObj (tmp, NULL));
}

/**
 * Call zinc->configure ( -width )
 *
 * @param value the width to set
 */
void Zinc::setWidth (int value)
{
  //call .zinc configure -width value
  p1[0] = id;
  p1[1] = ZFCT_configure;
  p1[2] = ZOPT_width;
  p1[3] = Z_INT_POOL (0, value);
  // call the function with 4 arguments
  z_command (4, "setWidth Failed : ");

  char *strid = Tcl_GetString(id);
  //call the Tk function pack
  String packCmd = String ("pack ") + strid + " -expand 1 -fill both";
  Tcl_Eval (interp, packCmd.c_str ());
}

/**
 * Call zinc->cget ( -width )
 *
 * @return width value
 */
int Zinc::getWidth ()
{
  Tcl_Obj* tmp;
  //discard old results
  Tcl_ResetResult (interp);
  //call .zinc cget -width
  p1[0] = id;
  p1[1] = ZFCT_cget;
  p1[2] = ZOPT_width;
  // call the function with 3 arguments
  z_command (3, "getWidth Failed : ");

  //retreive the result as an integer
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetIntFromObj (interp, tmp, &value),
              "getWidth Failed : ");
  return value;
}

/**
 * Call zinc->configure ( -height )
 *
 * @param value the height to set
 */
void Zinc::setHeight (int value)
{
  //call .zinc configure -height value
  p1[0] = id;
  p1[1] = ZFCT_configure;
  p1[2] = ZOPT_height;
  p1[3] = Z_INT_POOL (0, value);
  // call the function with 4 arguments
  z_command (4, "setHeight Failed : ");

  char *strid = Tcl_GetString(id);
  //call the Tk function pack
  String packCmd = String ("pack ") + strid + " -expand 1 -fill both";
  Tcl_Eval (interp, packCmd.c_str ());
}

/**
 * Call zinc->cget ( -height )
 *
 * @return height value
 */
int Zinc::getHeight ()
{
  Tcl_Obj* tmp;
  //discard old results
  Tcl_ResetResult (interp);
  //call .zinc cget -height
  p1[0] = id;
  p1[1] = ZFCT_cget;
  p1[2] = ZOPT_height;
  // call the function with 3 arguments
  z_command (3, "getHeight Failed : ");

  //retreive the result as an integer
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetIntFromObj (interp, tmp, &value),
              "getHeight Failed : ");
  return value;
}

/**
 * Call zinc->configure ( -borderwidth )
 *
 * @param value the borderwidth to set
 */
void Zinc::setBorderwidth (int value)
{
  //call .zinc configure -borderwidth value
  p1[0] = id;
  p1[1] = ZFCT_configure;
  p1[2] = ZOPT_borderwidth;
  p1[3] = Z_INT_POOL (0, value);
  // call the function with 4 arguments
  z_command (4, "setBorderwidth Failed : ");
}

/**
 * Call zinc->cget ( -borderwidth )
 *
 * @return borderwidth value
 */
int Zinc::getBorderwidth ()
{
  Tcl_Obj* tmp;
  //discard old results
  Tcl_ResetResult (interp);
  //call .zinc cget -borderwidth
  p1[0] = id;
  p1[1] = ZFCT_cget;
  p1[2] = ZOPT_borderwidth;
  // call the function with 3 arguments
  z_command (3, "getBorderwidth Failed : ");

  //retreive the result as an integer
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetIntFromObj (interp, tmp, &value),
              "getBorderwidth Failed : ");
  return value;
}

/**
 * Call zinc->configure ( -font )
 *
 * @param value the font to set
 */
void Zinc::setFont (ZincFont* value)
{
  //call .zinc configure -font value
  p1[0] = id;
  p1[1] = ZFCT_configure;
  p1[2] = ZOPT_font;
  p1[3] = Z_STR_POOL (0, value->name.c_str(), value->name.length());
  // call the function with 4 arguments
  z_command (4, "setFont Failed : ");
}

/**
 * Call zinc->cget ( -font )
 *
 * @return font value
 */
ZincFont* Zinc::getFont ()
{
  //discard old results
  Tcl_ResetResult (interp);
  //call .zinc cget -font
  p1[0] = id;
  p1[1] = ZFCT_cget;
  p1[2] = ZOPT_font;
  // call the function with 3 arguments
  z_command (3, "getFont Failed : ");

  //retreive the result as a string
  return new ZincFont (Tcl_GetStringResult (interp));
}


/*****************************************
          WIDGET METHODS
*****************************************/
/**
 * How To call Zinc or Tcl functions:
 *
 * All arguments of the function are Tcl_Obj. To accelerate their call, there
 * is a pool of preconstructed Tcl_Obj and some often used constant Tcl_Obj.
 * p1 and p2 are tables of pointers to be used for arguments.
 * Fill p1 using either predefined objects like ZITM_* or a pool objet that
 * you can fill with the value you want.
 *  Ex : p1[1] = ZFCT_add;
 * Macros have been defined to fill and use a pool object
 *  Ex : p1[2] = Z_INT_POOL(1, 200);
 * Do not use twice the same pool index for the same function call.
 * p2 is used to construct and argument which is a list of Tcl_Obj.
 * To call the function use z_tcl_call which automaticly handle error return
 * codes or z_command to call a Zinc command which handle all arguments too.
 */

/**
 * Get the bounding box of an item
 *
 * @param item the item to get bbox
 * @param bbox a table where we'll put the bounding box
 *             bbox[0] = x0, bbox[1] = y0, bbox[2] = xc, bbox[3] = yc
 */
void Zinc::bbox (ZincItem* item, double _bbox[4])
{
  Tcl_Obj* tmp;
  Tcl_Obj** list;
  int count;
  //discard old results
  Tcl_ResetResult (interp);
  // call .zinc bbox item
  p1[0] = id;
  p1[1] = ZFCT_bbox;
  p1[2] = item->object;

  // call the function with 3 arguments
  z_command (3, "bbox Failed : ");

  //retreive the result as a list
  tmp = Tcl_GetObjResult (interp);
  z_tcl_call (Tcl_ListObjGetElements (interp, tmp, &count, &list),
              "bbox Failed : ");
  //extract 4 double from the list
  if (count != 4)
  {
    throw  ZincException (String ("bbox Failed count=") + itos(count),
                          __FILE__, __LINE__);
  }
  z_tcl_call (Tcl_GetDoubleFromObj (interp, list[0], &_bbox[0]),
              "bbox Failed");
  z_tcl_call (Tcl_GetDoubleFromObj (interp, list[1], &_bbox[1]),
              "bbox Failed");
  z_tcl_call (Tcl_GetDoubleFromObj (interp, list[2], &_bbox[2]),
              "bbox Failed");
  z_tcl_call (Tcl_GetDoubleFromObj (interp, list[3], &_bbox[3]),
              "bbox Failed");
}


/**
 * Get the bounding box of an item in its parent group
 *
 * @param item the item to get bbox in its parent group
 * @param bbox a table where we'll put the bounding box
 *             bbox[0] = x0, bbox[1] = y0, bbox[2] = xc, bbox[3] = yc
 */
void Zinc::relativeBbox (ZincItem* item, double _bbox[4])
{
  //1) get bounding bbox
  double tempBbox[4];
  this->bbox (item, tempBbox);
  
  //2) call transform
  Tcl_Obj* tmp;
  Tcl_Obj** list;
  int count;
  //discard old results
  Tcl_ResetResult (interp);
  // call .zinc transform device parentGroup {_bbox[0] _bbox[1] _bbox[2] _bbox[3]}
  p1[0] = id;
  p1[1] = ZFCT_transform;
  p1[2] = ZFCT_device;
  p1[3] = item->object;

  //coordinates as a list
  p2[0] = Z_DBL_POOL (0, tempBbox[0]);
  p2[1] = Z_DBL_POOL (1, tempBbox[1]);
  p2[2] = Z_DBL_POOL (2, tempBbox[2]);
  p2[3] = Z_DBL_POOL (3, tempBbox[3]);
  p1[4] = Z_LST_POOL (4, p2, 4);

  // call the function with 5 arguments
  z_command (5, "relativeBbox z_command Failed : ");
  //free the list in pool No 4
  Z_CLEANLIST (4);

  //retreive the result as a list
  tmp = Tcl_GetObjResult (interp);
  z_tcl_call (Tcl_ListObjGetElements (interp, tmp, &count, &list),
              "relativeBbox z_tcl_call Failed : ");

  //3) extract 4 double from the list
  if (count != 4)
  {
    throw  ZincException (String ("relativeBbox Failed count=") + itos(count),
                          __FILE__, __LINE__);
  }
  z_tcl_call (Tcl_GetDoubleFromObj (interp, list[0], &_bbox[0]),
              "relativeBbox Failed");
  z_tcl_call (Tcl_GetDoubleFromObj (interp, list[1], &_bbox[1]),
              "relativeBbox Failed");
  z_tcl_call (Tcl_GetDoubleFromObj (interp, list[2], &_bbox[2]),
              "relativeBbox Failed");
  z_tcl_call (Tcl_GetDoubleFromObj (interp, list[3], &_bbox[3]),
              "bbox Failed");
}




/**
 * Change the group of an item
 *
 * @param item the item to move
 * @param parentGroup new group for the item
 */
void Zinc::chggroup (ZincItem *item, ZincItem *parentGroup)
{
  // call .zinc chggroup item parentGroup
  p1[0] = id;
  p1[1] = ZFCT_chggroup;
  p1[2] = item->object;
  p1[3] = Z_PARENTGROUP (parentGroup);
  // call the function with 4 arguments
  z_command (4, "chggroup Failed : ");
}

/**
 * Clone an item
 *
 * @param item the item to clone
 * @return the cloned item
 */
ZincItem* Zinc::clone (ZincItem *item)
{
  // call .zinc clone item
  p1[0] = id;
  p1[1] = ZFCT_clone;
  p1[2] = item->object;
  // call the function with 3 arguments
  z_command (3, "clone Failed: ");

  //retreive the result as a tcl_obj
  return new ZincItem (Tcl_GetObjResult (interp));
}

/**
 * Get the number of contour of an item
 *
 * @return number of contour
 */
int Zinc::contour (ZincItem *item)
{
  Tcl_Obj* tmp;
  int result;
  // call .zinc contour item
  p1[0] = id;
  p1[1] = ZFCT_contour;
  p1[2] = item->object;
  // call the function with 3 arguments
  z_command (3, "contour Failed: ");

  //retreive the result as an int
  tmp = Tcl_GetObjResult (interp);
  z_tcl_call (Tcl_GetIntFromObj (interp, tmp, &result),
              "contour Failed: ");
  return result;
}

/**
 * Set the contour of an item to the one of an other
 *
 * @param item the item on which we set the contour
 * @param flag the operation to do on the contour
 * @param reference the item to set contour from
 * @return the number of contour
 */
int Zinc::contour (ZincItem *item, itemOperator flag, ZincItem *reference)
{
  Tcl_Obj* tmp;
  int result;
  //discard old results
  Tcl_ResetResult (interp);
  // call .zinc contour item flag reference
  p1[0] = id;
  p1[1] = ZFCT_contour;
  p1[2] = item->object;

  //different possible actions depending on the flag
  switch (flag)
  {
  case item_add_clockwise:
    p1[3] = ZFCT_add;
    p1[4] = Z_INT_POOL (0, -1); //add clockwise (-1)
    break;
  case item_add_counterclockwise:
    p1[3] = ZFCT_add;
    p1[4] = Z_INT_POOL (0, 1); //add counterclockwise (1)
    break;
  default:
    p1[3] = ZFCT_remove;
    p1[4] = Z_INT_POOL (0, 0); //no meaning (0)
  }
  // contour index (0)
  p1[5] = Z_INT_POOL (1, 0);
  // item reference
  p1[6] = reference->object;

  // call the function with 7 arguments
  z_command (7, "contour Failed: ");

  // retreive the result as an int
  tmp = Tcl_GetObjResult (interp);
  z_tcl_call (Tcl_GetIntFromObj (interp, tmp, &result),
              "contour Failed: ");
  return result;
}

/**
 * Set the contour of an item
 *
 * @param item the item on which we set the contour
 * @param add true to add a path, false to remove
 * @param reference the new contour
 * @return the number of contour
 */
int Zinc::contour (ZincItem *item, bool add, ZincPath *_contour)
{
  Tcl_Obj* tmp;
  int result;
  //discard old results
  Tcl_ResetResult (interp);
  // call .zinc contour item flag contour
  p1[0] = id;
  p1[1] = ZFCT_contour;
  p1[2] = item->object;

  //different possible actions depending on the add flag
  if (add)
  {
    p1[3] = ZFCT_add;
    p1[4] = Z_INT_POOL (0, 0); //add contour (0)
  }
  else
  {
    p1[3] = ZFCT_remove;
    p1[4] = Z_INT_POOL (0, 0); //no meaning (0)
  }
  // contour index
  p1[5] = Z_INT_POOL (1, 0);
  //contour
  p1[6] = _contour->getTable ();

  // call the function with 7 arguments
  z_command (7, "contour Failed: ");

  // retreive the result as an integer
  tmp = Tcl_GetObjResult (interp);
  z_tcl_call (Tcl_GetIntFromObj (interp, tmp, &result),
              "contour Failed: ");
  return result;
}

/**
 * Set or modify the coordinates of an item
 *
 * @param item the item to modify
 * @param contour new coords for the item
 * @param add true to add coords, false to replace
 * @param contourIndex the contour do modify
 * @param coordIndex the coordinate to modify (WARNING, path must be one
 *                   point if the is not the default)
 */
void Zinc::coords (ZincItem *item, ZincPath *_contour, bool add,
                   int contourIndex, int coordIndex)
{
  int i;
  // call .zinc contour item ?flag? ?contourIndex? ?coordIndex? _contour
  p1[0] = id;
  p1[1] = ZFCT_coords;
  p1[2] = item->object;

  // use i as a variable index for parameters
  i = 3; // last parameter is p1[2]
  // do we add or not
  if (add)
  {
    p1[i++] = ZFCT_add;
  }

  //ith there a contour
  if (contourIndex != -1)
  {
    p1[i++] = Z_INT_POOL (1, contourIndex);

    //is there a coord index
    if (coordIndex != -1)
    {
      p1[i++] = Z_INT_POOL (1, coordIndex);
    }
  }

  p1[i++] = _contour->getTable ();

  // call the function with i arguments
  z_command (i, "coords Failed: ");
}

/**
 * Remove coords of an item
 *
 * @param item the item to modify
 * @param coordIndex the coordinate to rmove
 * @param contourIndex the contour on which we remove
 */
void Zinc::coordsRemove (ZincItem *item, int coordIndex, int contourIndex)
{
  int i;
  // call .zinc coords item remove ?contourIndex?
  p1[0] = id;
  p1[1] = ZFCT_coords;
  p1[2] = item->object;
  p1[3] = ZFCT_remove;

  i = 4;
  // is there a contourIndex
  if (contourIndex != -1)
  {
    p1[i++] = Z_INT_POOL (1, contourIndex);
  }
  p1[i++] = Z_INT_POOL (1, coordIndex);

  // call the function with i arguments
  z_command (i, "coordsRemove Failed: ");
}

/**
 * Add a tag to an item
 *
 * @param item the item to add tag to
 * @param tag a tag to add
 */
void Zinc::addTag (ZincItem *item, String tag)
{
  // call .zinc addtag tag withtag
  p1[0] = id;
  p1[1] = ZFCT_addtag;
  p1[2] = Z_STR_POOL (0, tag.c_str (), tag.length ());
  p1[3] = ZITM_withtag;
  p1[4] = item->object;
  // call the function with 5 arguments
  z_command (5, "addTag Failed: ");
}

/**
 * Remove a tag from an item
 *
 * @param item the item to remove tag from
 * @param tag a tag to remove
 */  
void Zinc::dTag (ZincItem *item, String tag)
{
  // call .zinc dtag item tag
  p1[0] = id;
  p1[1] = ZFCT_dtag;
  p1[2] = item->object;

  int i = 3;
  //create a tg if nexessary
  if (tag != "")
  {
    p1[i++] = Z_STR_POOL (0, tag.c_str (), tag.length ());
  }

  // call the function with i arguments
  z_command (i, "dTag Failed: ");
}

/**
 * List all tags of an item
 * It's up to the caller to delete the resulting table
 *
 * @param item the item to list tag from
 * @param lagList a pointer to a table of String containing tags
 * @return the number of tags
 */
int Zinc::getTags (ZincItem *item, String*** tagList)
{
  Tcl_Obj* tmp;
  Tcl_Obj** list;
  int count;

  //discard old results
  Tcl_ResetResult (interp);
  // call .zinc gettags item  
  p1[0] = id;
  p1[1] = ZFCT_gettags;
  p1[2] = item->object;
  // call the function with 3 arguments
  z_command (3, "getTags Failed : ");

  //retreive the result as a list
  tmp = Tcl_GetObjResult (interp);
  z_tcl_call (Tcl_ListObjGetElements (interp, tmp, &count, &list),
              "bbox Failed : ");

  // put strings into a new table 
  char *str;
  //store the table into tagList
  (*tagList) = new String* [count];

  // fill the table
  for (int i (0) ; i < count ; i++)
  {
    str = Tcl_GetString (list[i]);
    (*tagList)[i] = new String (str);
  }
  return count;
}

/**
 * Set the focus to an item
 *
 * @param item the item to set the focus to
 */
void Zinc::focus (ZincItem *item)
{
  // .zinc focus item
  p1[0] = id;
  p1[1] = ZFCT_focus;
  p1[2] = item->object;
  // call the function with 3 arguments
  z_command (3, "focus Failed: ");
}

/**
 * Tell if the name is a gradient name
 *
 * @param gname a gradient name
 * @return true if the name is a gradient name, false otherwise
 */
bool Zinc::isGname (String _gname)
{
  Tcl_Obj* tmp;
  int result;
  //discard old results
  Tcl_ResetResult (interp);
  // call .zinc gname _gname
  p1[0] = id;
  p1[1] = ZFCT_gname;
  p1[2] = Z_STR_POOL (0, _gname.c_str (), _gname.length ());
  // call the function with 3 arguments
  z_command (3, "isGname Failed: ");

  //retreive the result as a boolean
  tmp = Tcl_GetObjResult (interp);
  z_tcl_call (Tcl_GetBooleanFromObj (interp, tmp, &result),
              "isGname Failed: ");
  return bool (result);
}

/**
 * Create a named gradient
 *
 * @param gradient a gradient
 * @param gname a gradient name
 */
void Zinc::gname (String gradient, String _gname)
{
  // call .zinc gname gradient gname
  p1[0] = id;
  p1[1] = ZFCT_gname;
  p1[2] = Z_STR_POOL (0, gradient.c_str (), gradient.length ());
  p1[3] = Z_STR_POOL (1, _gname.c_str (), _gname.length ());
  // call the function with 4 arguments
  z_command (4, "gname Failed: ");
}

/**
 * Retreive the group of an item
 *
 * @param item the item to get the group from
 * @return the group
 */
ZincItem* Zinc::group (ZincItem *item)
{
  Tcl_Obj* tmp;
  //discard old results
  Tcl_ResetResult (interp);
  // call .zinc group item
  p1[0] = id;
  p1[1] = ZFCT_group;
  p1[2] = item->object;
  // call the function with 3 arguments
  z_command (3, "group Failed: ");

  //retreive the result as a tcl_obj
  tmp = Tcl_GetObjResult (interp);
  return new ZincItem (tmp);
}

/**
 * Reorder items to lower one
 *
 * @param item the item to lower
 */
void Zinc::lower (ZincItem *item)
{
  // call .zinc lower item
  p1[0] = id;
  p1[1] = ZFCT_lower;
  p1[2] = item->object;
  // call the function with 3 arguments
  z_command (3, "lower Failed: ");
}

/**
 * Reorder items to lower one
 *
 * @param item the item to lower
 * @param belowThis and item that will be over item
 */
void Zinc::lower (ZincItem *item, ZincItem *belowThis)
{
  // call .zinc lower item belowThis
  p1[0] = id;
  p1[1] = ZFCT_lower;
  p1[2] = item->object;
  p1[3] = belowThis->object;
  // call the function with 4 arguments
  z_command (4, "lower Failed: ");
}

/**
 * Reorder items to raise one
 *
 * @param item the item to raise
 */
void Zinc::raise (ZincItem *item)
{
  // call .zinc raise item
  p1[0] = id;
  p1[1] = ZFCT_raise;
  p1[2] = item->object;
  // call the function with 3 arguments
  z_command (3, "raise Failed: ");
}

/**
 * Reorder items to raise one
 *
 * @param item the item to raise
 * @param aboveThis an item that will be under item
 */
void Zinc::raise (ZincItem *item, ZincItem *aboveThis)
{
  // call .zinc raise item aboveThis
  p1[0] = id;
  p1[1] = ZFCT_raise;
  p1[2] = item->object;
  p1[3] = aboveThis->object;
  // call the function with 4 arguments
  z_command (4, "raise Failed: ");
}

/**
 * Return the type of an item
 *
 * @param item an item
 * @return the type of the item
 */
itemType Zinc::type (ZincItem *item)
{
  Tcl_Obj *tmp;
  //discard old results
  Tcl_ResetResult (interp);
  // call .zinc type item
  p1[0] = id;
  p1[1] = ZFCT_type;
  p1[2] = item->object;
  // call the function with 3 arguments
  z_command (3, "type Failed: ");

  //retreive the result as a string
  tmp = Tcl_GetObjResult (interp);

  // convert the string to the right enum value
  int value;
  z_tcl_call (Tcl_GetIndexFromObj (interp, tmp,
                                   itemTypeStrings, 
                                   "itemType",
                                   0, &value),
              "type Failed : ");
  return itemType (value);
}

/**
 * Create a Zinc Tag that can be used in place of any item
 *  for zinc functions that must be called using tagOrId
 *
 * @param tag the text of the tag
 * @return a tag item
 */
ZincItem* Zinc::createTag(String tag)
{
  //just create an item
  return new ZincItem (Tcl_NewStringObj (tag.c_str (), tag.length ()));
}

/*******************************************************
                ITEM MANIPULATION
*******************************************************/
/**
 * How To call Zinc or Tcl functions:
 *
 * All arguments of the function are Tcl_Obj. To accelerate their call, there
 * is a pool of preconstructed Tcl_Obj and some often used constant Tcl_Obj.
 * p1 and p2 are tables of pointers to be used for arguments.
 * Fill p1 using either predefined objects like ZITM_* or a pool objet that
 * you can fill with the value you want.
 *  Ex : p1[1] = ZFCT_add;
 * Macros have been defined to fill and use a pool object
 *  Ex : p1[2] = Z_INT_POOL(1, 200);
 * Do not use twice the same pool index for the same function call.
 * p2 is used to construct and argument which is a list of Tcl_Obj.
 * To call the function use z_tcl_call which automaticly handle error return
 * codes or z_command to call a Zinc command which handle all arguments too.
 */

/**
 * Suppress an item
 *
 * @param item the item to suppress
 */
void Zinc::itemRemove (ZincItem *item)
{
  //call .zinc remove item
  p1[0] = id;
  p1[1] = ZFCT_remove;
  p1[2] = item->object;
  // call the function with 3 arguments
  z_command (3, "itemRemove failed :");
}

/**
 * Create a group item
 *
 * @param parentGroup group where we'll put the new group, if NULL we create
 * in the defaults group
 * @return the group item
 */
ZincItem *Zinc::itemCreateGroup (ZincItem *parentGroup)
{
  //call .zinc add group parentGroup
  p1[0] = id;
  p1[1] = ZFCT_add;
  p1[2] = ZITM_group;
  p1[3] = Z_PARENTGROUP (parentGroup);
  // call the function with 4 arguments
  z_command (4, "itemCreateGroup failed :");

  return new ZincItem (Tcl_GetObjResult (interp));
}

/**
 * Create a rectangle item
 *
 * @param parentGroup group where we'll put it
 * @param x y width height the coordinates of the new rectangle
 * @return the rectangle item
 */
ZincItem* Zinc::itemCreateRectangle (ZincItem *parentGroup, double x, double y,
                                     double width, double height)
{
  //call .zinc add rectangle parentGroup {coords}
  p1[0] = id;
  p1[1] = ZFCT_add;
  p1[2] = ZITM_rectangle;
  p1[3] = Z_PARENTGROUP (parentGroup);
  //coordinates as a list
  p2[0] = Z_DBL_POOL (0, x);
  p2[1] = Z_DBL_POOL (1, y);
  p2[2] = Z_DBL_POOL (2, width + x);
  p2[3] = Z_DBL_POOL (3, height + y);
  p1[4] = Z_LST_POOL (4, p2, 4); // a list with 4 items
  // call the function with 4 arguments
  z_command (5, "itemCreateRectangle failed :");

  //clear the list in the pool No 4
  Z_CLEANLIST (4);
  
  return new ZincItem (Tcl_GetObjResult (interp));
}

/**
 * Create an arc item
 *
 * @param parentGroup group where we'll put it
 * @param x y width height the coordinates of the new rectangle
 * @return the arc item
 */
ZincItem *Zinc::itemCreateArc (ZincItem *parentGroup, double x, double y,
                               double width, double height)
{
  //call .zinc add arc parentGroup {coords}
  p1[0] = id;
  p1[1] = ZFCT_add;
  p1[2] = ZITM_arc;
  p1[3] = Z_PARENTGROUP (parentGroup);
  //coordinates as a list
  p2[0] = Z_DBL_POOL (0, x);
  p2[1] = Z_DBL_POOL (1, y);
  p2[2] = Z_DBL_POOL (2, width + x);
  p2[3] = Z_DBL_POOL (3, height + y);
  p1[4] = Z_LST_POOL (4, p2, 4);
  // call the function with 5 arguments
  z_command (5, "itemCreateArc failed :");

  //clear the list in the pool No 4 to reuse it later
  Z_CLEANLIST (4);

  return new ZincItem (Tcl_GetObjResult (interp));  
}

/**
 * Create a text item
 *
 * @param parentGroup group where we'll put it
 * @return the text item
 */
ZincItem *Zinc::itemCreateText (ZincItem *parentGroup)
{
  //call .zinc add text parentGroup
  p1[0] = id;
  p1[1] = ZFCT_add;
  p1[2] = ZITM_text;
  p1[3] = Z_PARENTGROUP (parentGroup);
  // call the function with 4 arguments
  z_command (4, "itemCreateText failed :");

  return new ZincItem (Tcl_GetObjResult (interp));
}

/**
 * Create a curve item
 *
 * @param parentGroup group where we'll put it
 * @param path the path to display
 * @return the curve item
 */
ZincItem *Zinc::itemCreateCurve (ZincItem *parentGroup, ZincPath *path)
{
  Tcl_Obj *table;
  table = path->getTable ();
  //call .zinc add curve parentGroup {path}
  p1[0] = id;
  p1[1] = ZFCT_add;
  p1[2] = ZITM_curve;
  p1[3] = Z_PARENTGROUP (parentGroup);
  p1[4] = table;
  // call the function with 5 arguments
  z_command (5, "itemCreateCurve failed :");
  return new ZincItem (Tcl_GetObjResult (interp));
}


/**
 * Create an icon item
 *
 * @param parentGroup group where we'll put it
 * @param image a zincImage to display
 * @return the icon item
 */
ZincItem *Zinc::itemCreateIcon (ZincItem *parentGroup, ZincImage* image)
{
  //call .zinc add icon parentGroup
  p1[0] = id;
  p1[1] = ZFCT_add;
  p1[2] = ZITM_icon;
  p1[3] = Z_PARENTGROUP (parentGroup);
  // call the function with 4 arguments
  z_command (4, "itemCreateIcon failed :");

  //retreive the result
  ZincItem *result = new ZincItem (Tcl_GetObjResult (interp));
  //to be able to set the image
  itemSetImage (result, image);
  
  return result;  
}

/**************************************************
           TRANSFORMATION METHODS
**************************************************/

/**
 * How To call Zinc or Tcl functions:
 *
 * All arguments of the function are Tcl_Obj. To accelerate their call, there
 * is a pool of preconstructed Tcl_Obj and some often used constant Tcl_Obj.
 * p1 and p2 are tables of pointers to be used for arguments.
 * Fill p1 using either predefined objects like ZITM_* or a pool objet that
 * you can fill with the value you want.
 *  Ex : p1[1] = ZFCT_add;
 * Macros have been defined to fill and use a pool object
 *  Ex : p1[2] = Z_INT_POOL(1, 200);
 * Do not use twice the same pool index for the same function call.
 * p2 is used to construct and argument which is a list of Tcl_Obj.
 * To call the function use z_tcl_call which automaticly handle error return
 * codes or z_command to call a Zinc command which handle all arguments too.
 */

/**
 * Translate the item
 *
 * @param item the item to which we apply the transform
 * @param dx dy translation vector
 */
void Zinc::itemTranslate (ZincItem * item, double dx, double dy)
{
  // call .zinc translate item dx dy
  p1[0] = id;
  p1[1] = ZFCT_translate;
  p1[2] = item->object;
  p1[3] = Z_DBL_POOL (0, dx);
  p1[4] = Z_DBL_POOL (1, dy);
  // call the function with 5 arguments
  z_command (5, "itemTranslateRelative Failed : ");
}

/**
 * Translate the item 
 *
 * @param item the item to which we apply the transform
 * @param x y translation vector
 * @param absolute true if the translation is absolute
 */
void Zinc::itemTranslate (ZincItem * item, double x, double y, bool absolute)
{
  // call .zinc translate item x y absolute
  p1[0] = id;
  p1[1] = ZFCT_translate;
  p1[2] = item->object;
  p1[3] = Z_DBL_POOL (0, x);
  p1[4] = Z_DBL_POOL (1, y);
  p1[5] = Z_BOO_POOL (2, absolute);
  // call the function with 6 arguments
  z_command (6, "itemTranslateAbsolute Failed : ");
}

/**
 * Rotate an item
 *
 * @param item the item to which we apply the transform
 * @param angle the angle to rotate in radian
 */
void Zinc::itemRotate (ZincItem * item, double angle)
{
  // call .zinc rotate item angle
  p1[0] = id;
  p1[1] = ZFCT_rotate;
  p1[2] = item->object;
  p1[3] = Z_DBL_POOL (0, angle);
  // call the function with 4 arguments
  z_command (4, "itemRotate (angle) Failed : ");
}

/**
 * Rotate an item
 *
 * @param item the item to which we apply the transform
 * @param angle the angle to rotate in radian
 * @param x y the center of the rotation
 */
void Zinc::itemRotate (ZincItem * item, double angle, double x, double y)
{
  // call .zinc rotate item angle x y
  p1[0] = id;
  p1[1] = ZFCT_rotate;
  p1[2] = item->object;
  p1[3] = Z_DBL_POOL (0, angle);
  p1[4] = Z_DBL_POOL (1, x);
  p1[5] = Z_DBL_POOL (2, y);  
  // call the function with 6 arguments
  z_command (6, "itemRotateDegree (angle,center) Failed : ");
}

/**
 * Rotate an item
 *
 * @param item the item to which we apply the transform
 * @param angle the angle to rotate
 * @param degree true for an angle in degree, false for an angle in radians
 */
void Zinc::itemRotate (ZincItem * item, double angle, bool degree)
{
  // call .zinc rotate item angle degree
  p1[0] = id;
  p1[1] = ZFCT_rotate;
  p1[2] = item->object;
  p1[3] = Z_DBL_POOL (0, angle);
  p1[4] = Z_BOO_POOL (1, degree);
  // call the function with 5 arguments
  z_command (5, "itemRotate (angle,degree) Failed : ");
}

/**
 * Rotate an item
 *
 * @param item the item to which we apply the transform
 * @param angle the angle to rotate in radian
 * @param x y the center of the rotation
 * @param degree true for an angle in degree, false for an angle in radians
 */
void Zinc::itemRotate (ZincItem * item, double angle, double x, double y,
                       bool degree)
{
  // call .zinc rotate item angle degree x y
  p1[0] = id;
  p1[1] = ZFCT_rotate;
  p1[2] = item->object;
  p1[3] = Z_DBL_POOL (0, angle);
  p1[4] = Z_BOO_POOL (1, degree);
  p1[5] = Z_DBL_POOL (2, x);
  p1[6] = Z_DBL_POOL (3, y);  
  // call the function with 7 arguments
  z_command (7, "itemRotate (angle,center,degree) Failed : ");
}

/**
 * Scale an item
 *
 * @param item the item to which we apply the transform
 * @param ax horizontal scale
 * @param ay vertical scale
 */
void Zinc::itemScale (ZincItem * item, double ax, double ay)
{
  // call .zinc scale item ax ay
  p1[0] = id;
  p1[1] = ZFCT_scale;
  p1[2] = item->object;
  p1[3] = Z_DBL_POOL (0, ax);
  p1[4] = Z_DBL_POOL (1, ay);
  // call the function with 5 arguments
  z_command (5, "itemScale Failed : ");
}

/**
 * Scale an item using a specified center
 *
 * @param item the item to which we apply the transform
 * @param ax horizontal scale
 * @param ay vertical scale
 * @param cx cy center of the scale
 */
void Zinc::itemScale (ZincItem * item, double ax, double ay, double cx, double cy)
{
  // call .zinc scale item ax ay cx cy
  p1[0] = id;
  p1[1] = ZFCT_scale;
  p1[2] = item->object;
  p1[3] = Z_DBL_POOL (0, ax);
  p1[4] = Z_DBL_POOL (1, ay);
  p1[5] = Z_DBL_POOL (2, cx);
  p1[6] = Z_DBL_POOL (3, cy);
  // call the function with 7 arguments
  z_command (7, "itemScale (center) Failed : ");
}

/**
 * Skew an item
 *
 * @param item the item to which we apply the transform
 * @param sx horizontal skew
 * @param sy vertical skew
 */
void Zinc::itemSkew (ZincItem * item, double sx, double sy)
{
  // call .zinc skew item sx sy
  p1[0] = id;
  p1[1] = ZFCT_skew;
  p1[2] = item->object;
  p1[3] = Z_DBL_POOL (0, sx);
  p1[4] = Z_DBL_POOL (1, sy);
  // call the function with 5 arguments
  z_command (5, "itemSkew Failed : ");
}

/**
 * Skew an item horizontaly
 *
 * @param item the item to which we apply the transform
 * @param sx horizontal skew
 */
void Zinc::itemSkewX (ZincItem * item, double sx)
{
  // call .zinc skew item sx 0
  p1[0] = id;
  p1[1] = ZFCT_skew;
  p1[2] = item->object;
  p1[3] = Z_DBL_POOL (0, sx);
  p1[4] = Z_DBL_POOL (1, 0);
  // call the function with 5 arguments
  z_command (5, "itemSkewX Failed : ");
}

/**
 * Skew an item verticaly
 *
 * @param item the item to which we apply the transform
 * @param sy vertical skew
 */
void Zinc::itemSkewY (ZincItem * item, double sy)
{
  // call .zinc skew item 0 sy
  p1[0] = id;
  p1[1] = ZFCT_skew;
  p1[2] = item->object;
  p1[3] = Z_DBL_POOL (0, 0);
  p1[4] = Z_DBL_POOL (1, sy);
  // call the function with 5 arguments
  z_command (5, "itemSkewY Failed : ");
}
  
/**
 * Reset all transformations associated with the item
 *
 * @param item the item to which we apply the transform
 */
void Zinc::itemResetTransformation (ZincItem * item)
{
  // call .zinc treset item
  p1[0] = id;
  p1[1] = ZFCT_treset;
  p1[2] = item->object;
  // call the function with 3 arguments
  z_command (3, "itemResetTransformation Failed : ");
}

/**
 * Replace current transform by a matrix
 *
 * @param item the item to which we apply the transform
 * @param a,b,c,d,e,f the new transform matrix 
 */
void Zinc::itemSetTransformation (ZincItem * item,
                                  double a, double b, double c,
                                  double d, double e, double f)
{
  // call .zinc tset item a b c d e f
  p1[0] = id;
  p1[1] = ZFCT_tset;
  p1[2] = item->object;
  p1[3] = Z_DBL_POOL (0, a);
  p1[4] = Z_DBL_POOL (1, b);
  p1[5] = Z_DBL_POOL (2, c);
  p1[6] = Z_DBL_POOL (3, d);
  p1[7] = Z_DBL_POOL (4, e);
  p1[8] = Z_DBL_POOL (5, f);
  // call the function with 9 arguments
  z_command (9, "itemSetTransformation Failed : ");  
}

/**
 * Get current transform matrix
 * @param item the item to which we apply the transform
 * @param a,b,c,d,e,f places where we'll put the transform matrix
 */
void Zinc::itemGetTransformation (ZincItem * item,
                                  double *a, double *b, double *c,
                                  double *d, double *e, double *f)
{
  // bug in zinc (or not?), it doesn't reset result for the tget function
  //  or apennd a result instead of replacing it
  Tcl_ResetResult (interp);
  // call .zinc tget item
  p1[0] = id;
  p1[1] = ZFCT_tget;
  p1[2] = item->object;
  // call the function with 3 arguments
  z_command (3, "itemGetTransformation Failed : ");

  //retreive the result as a list object
  Tcl_Obj* tmp = Tcl_GetObjResult (interp);
  int num;
  Tcl_Obj** elems;
  z_tcl_call (Tcl_ListObjGetElements (interp, tmp, &num, &elems),
              "itemGetTransformation Failed : ");

  //num is necessarily 6, extract 6 double
  z_tcl_call (Tcl_GetDoubleFromObj(interp, elems[0], a),
              "itemGetTransformation Failed : ");
  z_tcl_call (Tcl_GetDoubleFromObj(interp, elems[1], b),
              "itemGetTransformation Failed : ");
  z_tcl_call (Tcl_GetDoubleFromObj(interp, elems[2], c),
              "itemGetTransformation Failed : ");
  z_tcl_call (Tcl_GetDoubleFromObj(interp, elems[3], d),
              "itemGetTransformation Failed : ");
  z_tcl_call (Tcl_GetDoubleFromObj(interp, elems[4], e),
              "itemGetTransformation Failed : ");
  z_tcl_call (Tcl_GetDoubleFromObj(interp, elems[5], f),
              "itemGetTransformation Failed : ");  
}


/**
 * Multiply current transform by a matrix
 *
 * @param item the item to which we apply the transform
 * @param a,b,c,d,e,f  transform matrix 
 */
void Zinc::itemMatrix (ZincItem * item,
                       double a, double b, double c,
                       double d, double e, double f)
{
  double a0,b0,c0,d0,e0,f0;
  double a1,b1,c1,d1,e1,f1;
  // get current transform
  itemGetTransformation (item, &a0, &b0, &c0, &d0, &e0, &f0);

  //multiply
  a1 = a * a0 + d * b0;
  b1 = b * a0 + e * b0;
  c1 = c * a0 + f * b0 + c0;
  d1 = a * d0 + d * e0;
  e1 = b * d0 + e * e0;
  f1 = c * d0 + f * e0 + f0;

  // set to new transform
  itemSetTransformation (item, a1, b1, c1, d1, e1, f1);
}

/**************************************************
                    BINDING
**************************************************/

/**
 * How To call Zinc or Tcl functions:
 *
 * All arguments of the function are Tcl_Obj. To accelerate their call, there
 * is a pool of preconstructed Tcl_Obj and some often used constant Tcl_Obj.
 * p1 and p2 are tables of pointers to be used for arguments.
 * Fill p1 using either predefined objects like ZITM_* or a pool objet that
 * you can fill with the value you want.
 *  Ex : p1[1] = ZFCT_add;
 * Macros have been defined to fill and use a pool object
 *  Ex : p1[2] = Z_INT_POOL(1, 200);
 * Do not use twice the same pool index for the same function call.
 * p2 is used to construct and argument which is a list of Tcl_Obj.
 * To call the function use z_tcl_call which automaticly handle error return
 * codes or z_command to call a Zinc command which handle all arguments too.
 */

//number of elements in the ZincEvent structure
#define EVENT_COUNT 10
//number of basic parameters to a widget callback
#define WIDGETCB_COUNT 3
//number of basic parameters to an item callback
#define ITEMCB_COUNT 4

//the equivalent of z_tcl_call able to be called in a callback
#define z_tcl_call2(fct,msg) \
  {                          \
    int result = (fct);      \
    if (result != TCL_OK)    \
    {                        \
      Tcl_AppendResult (Zinc::interp, msg, NULL); \
      return TCL_ERROR;      \
    }                        \
  }

/**
 * Real callback used by zinc TCL
 *
 * @param client_data the Zinc object
 * @param interp current interpreter
 * @param argc number of arguments
 * @param args table of arguments
 */
int tclCallback (ClientData client_data, Tcl_Interp *interp,
                  int argc, Tcl_Obj *CONST args[])
{
  Zinc *zinc = (Zinc*) client_data;
  int cb;
  ZincItem *item;
  void *userData;
  ZincEvent *ev;
  long value;
  
  //count arguments
  if ((argc != WIDGETCB_COUNT + EVENT_COUNT) && (argc != ITEMCB_COUNT + EVENT_COUNT))
  {
    Tcl_SetResult (Zinc::interp, "Zinclib: Invalid argument count in tclCallback", NULL);
    return TCL_ERROR;
  }
  // skip the bind name
  args++;

  // get the item if this is an item bind
  if (argc == ITEMCB_COUNT + EVENT_COUNT)
  {
    // retreive item
    z_tcl_call2 (Tcl_GetLongFromObj (interp, args[0], &value),
                 "Zinclib: No item in tclCallback");
    item = (ZincItem*) value;
    args++;
  }

  // retreive callback
  z_tcl_call2 (Tcl_GetLongFromObj (interp, args[0], &value),
               "Zinclib: No callback in tclCallback");
  cb = value;

  // retreive userdata
  args++;
  z_tcl_call2 (Tcl_GetLongFromObj (interp, args[0], &value),
               "Zinclib: No userData in tclCallback");
  userData = (void*) value;

  // point args to events values
  args++;
  //fill event structure with all avent values we support
  ev = new ZincEvent;
  // x position of the mouse
  if (Tcl_GetIntFromObj (interp, args[0], &(ev->x)) != TCL_OK)
  {
    ev->x = 0;
  }
  // y position of the mouse
  if (Tcl_GetIntFromObj (interp, args[1], &(ev->y)) != TCL_OK)
  {
    ev->y = 0;
  }
  // keycode
  if (Tcl_GetIntFromObj (interp, args[2], &(ev->k)) != TCL_OK)
  {
    ev->k = 0;
  }
  // timestamp
  if (Tcl_GetLongFromObj (interp, args[3], &(ev->t)) != TCL_OK)
  {
    ev->t = 0;
  }
  // keysyms
  ev->K = String (Tcl_GetString (args[4]));
  // window height
  if (Tcl_GetIntFromObj (interp, args[5], &(ev->h)) != TCL_OK)
  {
    ev->h = 0;
  }
  // window width
  if (Tcl_GetIntFromObj (interp, args[6], &(ev->w)) != TCL_OK)
  {
    ev->w = 0;
  }
  // x position of the mouse within display 
  if (Tcl_GetIntFromObj (interp, args[7], &(ev->X)) != TCL_OK)
  {
    ev->X = 0;
  }
  // y position of the mouse within display 
  if (Tcl_GetIntFromObj (interp, args[8], &(ev->Y)) != TCL_OK)
  {
    ev->Y = 0;
  }
  // button pressed
  if (Tcl_GetIntFromObj (interp, args[9], &(ev->b)) != TCL_OK)
  {
    ev->b = 0;
  }
  
  // Call the callback
  if (argc == ITEMCB_COUNT + EVENT_COUNT)
  {
    // this is a callback on an item
    ZincItemCallback itemCb = (ZincItemCallback)cb;
    (*itemCb) (zinc, item, ev, userData);
  }
  else
  {
    // this is a callback on the zinc widget
    ZincWidgetCallback zincCb = (ZincWidgetCallback)cb;
    (*zincCb) (zinc, ev, userData);
  }
  
  delete ev;
  return TCL_OK;
}

/**
 * Bind a function to an event on the zinc widget
 *
 * @param eventSpecification tcl style event specicication
 * @param callBack the function which will be called back
 * @param userData data we will give back to the callback when called
 * @param add false to replace existing bind or true to add
 */
void Zinc::bind (String eventSpecification,
                 ZincWidgetCallback callBack, void *userData, bool add)
{
  // call bind .zinc eventSpec script
  const char* para[4];
  para[0] = "bind";
  para[1] = window.c_str ();
  para[2] = eventSpecification.c_str ();

  //create callback script
  // this script is a call to the tclCallback function using all arguments we need
  String script;
  // do we add or replace the callback
  if (add)
  {
    script = String("+");
  }
  script += tclCb + " ";                 // name of the tcl function we created
  script += ltos ((long)callBack) + " "; // the real callback (as a pointer)
  script += ltos ((long)userData) + " "; // the user data (as a pointer)
  script += "%x %y %k %t %K %h %w %X %Y %b";// arguments for the event structure
  para[3] = script.c_str ();

  //call the command with 4 arguments
  z_tcl_call ((*bndCmdInfo.proc)(bndCmdInfo.clientData, interp, 4, para),
              "bind Failed : ");
}

/**
 * Annulate a binding
 *
 * @param eventSpecification tcl style event specicication
 */
void Zinc::unbind (String eventSpecification)
{
  // call bind .zinc eventSpec ""
  const char* para[4];;
  para[0] = "bind";
  para[1] = window.c_str ();
  para[2] = eventSpecification.c_str ();
  para[3] = "";

  //call the command with 4 arguments
  z_tcl_call ((*bndCmdInfo.proc)(bndCmdInfo.clientData, interp, 4, para),
              "unbind Failed : ");
}

/**
 * Bind a function to an event on an item
 *
 * @param item the item on which to bind
 * @param eventSpecification tcl style event specicication
 * @param callBack the function which will be called back
 * @param userData data we will give back to the callback when called
 */
void Zinc::itemBind (ZincItem *item, String eventSpec,
                     ZincItemCallback callBack, void *userData, bool add)
{
  // call .zinc bind item eventSpec script
  p1[0] = id;
  p1[1] = ZFCT_bind;
  p1[2] = item->object;
  p1[3] = Z_STR_POOL (0, eventSpec.c_str (), eventSpec.length ());

  //create callback script
  // this script is a call to the tclCallback function using all arguments we need
  String script;
  // do we add or replace the callback
  if (add)
  {
    script = String("+");
  }
  script += tclCb + " ";                 // name of the tcl function we created
  script += ltos ((long)item) + " ";     // the item (as a pointer)
  script += ltos ((long)callBack) + " "; // the real callback (as a pointer)
  script += ltos ((long)userData) + " "; // the user data (as a pointer)
  script += "%x %y %k %t %K %h %w %X %Y %b";  // arguments for the event structure
  p1[4] = Z_STR_POOL (1, script.c_str (), script.length ());

  // call the widget command with 5 arguments
  z_command (5, "itemBind Failed : ");
}

/**
 * Annulate a binding
 *
 * @param item the item on which to unbind
 * @param eventSpecification tcl style event specicication
 */
void Zinc::itemUnbind (ZincItem *item, String eventSpec)
{
  // call .zinc bind item eventSpec ""
  p1[0] = id;
  p1[1] = ZFCT_bind;
  p1[2] = item->object;
  p1[3] = Z_STR_POOL (0, eventSpec.c_str (), eventSpec.length ());
  p1[4] = Z_STR_POOL (1, "", -1);

  //call the command with 5 arguments
  z_command (5, "itemUnbind Failed : ");
}

/*******************************************************
                STATIC PROCEDURES
*******************************************************/

/**
 * How To call Zinc or Tcl functions:
 *
 * All arguments of the function are Tcl_Obj. To accelerate their call, there
 * is a pool of preconstructed Tcl_Obj and some often used constant Tcl_Obj.
 * p1 and p2 are tables of pointers to be used for arguments.
 * Fill p1 using either predefined objects like ZITM_* or a pool objet that
 * you can fill with the value you want.
 *  Ex : p1[1] = ZFCT_add;
 * Macros have been defined to fill and use a pool object
 *  Ex : p1[2] = Z_INT_POOL(1, 200);
 * Do not use twice the same pool index for the same function call.
 * p2 is used to construct and argument which is a list of Tcl_Obj.
 * To call the function use z_tcl_call which automaticly handle error return
 * codes or z_command to call a Zinc command which handle all arguments too.
 */

/**
 * Loads the zinc library and initialize tcl and tk
 *
 * @param argv0 the name of the executable as passed in argv[0]
 */
void Zinc::loadZinc (char *argv0) throw (ZincException)
{
  //Initialise internal TCL structure
  Tcl_FindExecutable (argv0);
  //Create an interpreter
  interp = Tcl_CreateInterp();
  if (interp == NULL)
  {
    throw ZincException("Tcl_CreateInterp Error", __FILE__, __LINE__);
  }

  // set display
  Tcl_SetVar(interp, "env", "DISPLAY", TCL_GLOBAL_ONLY);
  //remove prompt
  Tcl_SetVar(interp, "tcl_interactive", "0", TCL_GLOBAL_ONLY);

  // needed for Default system startup file for Tcl-based applications
  z_tcl_call (Tcl_Init(interp), "Tcl_Init failed : ");

  //Initialize Tk
//  Tk_Init(interp);
  
  z_tcl_call (Tk_Init (interp), "Tk_Init failed : ");
  
  //Initialize Zinc
  z_tcl_call (Tkzinc_Init (interp), "Tkzinc_Init failed :");

  // Load Img package in order to handle PNG, JPEG, ..
  z_tcl_call (Tcl_GlobalEval (interp, "package require Img"), "Package Img not found");

  //Initialize objects pool
  for (int i(0); i<ZINC_POOL_COUNT ; i++)
  {
    pool[i] = Tcl_NewObj ();
    Tcl_IncrRefCount (pool[i]);
  }

  //initialise frame command info
  if (!Tcl_GetCommandInfo(interp, "toplevel", &topCmdInfo))
  {
    throw ZincException (String ("Toplevel command not found"),
                         __FILE__, __LINE__);
  }

  //initialise zinc command info
  if (!Tcl_GetCommandInfo(interp, "zinc", &zncCmdInfo))
  {
    throw ZincException (String ("Zinc command not found"),
                         __FILE__, __LINE__);
  }

  //initialise image command info
  if (!Tcl_GetCommandInfo(interp, "image", &imgCmdInfo))
  {
    throw ZincException (String ("Image command not found"),
                         __FILE__, __LINE__);
  }

  //initialise font command info
  if (!Tcl_GetCommandInfo(interp, "font", &fntCmdInfo))
  {
    throw ZincException (String ("Font command not found"),
                         __FILE__, __LINE__);
  }

  //initialise focus command info
  if (!Tcl_GetCommandInfo(interp, "focus", &focCmdInfo))
  {
    throw ZincException (String ("Focus command not found"),
                         __FILE__, __LINE__);
  }

  //initialise bind command info
  if (!Tcl_GetCommandInfo(interp, "bind", &bndCmdInfo))
  {
    throw ZincException (String ("Bind command not found"),
                        __FILE__, __LINE__);
  }
}


/**
 * Run tk mainloop and returns when there is no more Tk window
 */
void Zinc::zincMainLoop ()
{
  Tk_MainLoop();
}


/*******************************************************
          AUTOGENERATED METHODS (itemconfigure)
"code.cpp" in Tkzins/generic source from :
   ./gen.pl Arc.c Attrs.c Color.c Curve.c Draw.c  Group.c
        Image.c List.c Item.c Icon.c Rectangle.c tkZinc.c Text.c
*******************************************************/

/**
 * How To call Zinc or Tcl functions:
 *
 * All arguments of the function are Tcl_Obj. To accelerate their call, there
 * is a pool of preconstructed Tcl_Obj and some often used constant Tcl_Obj.
 * p1 and p2 are tables of pointers to be used for arguments.
 * Fill p1 using either predefined objects like ZITM_* or a pool objet that
 * you can fill with the value you want.
 *  Ex : p1[1] = ZFCT_add;
 * Macros have been defined to fill and use a pool object
 *  Ex : p1[2] = Z_INT_POOL(1, 200);
 * Do not use twice the same pool index for the same function call.
 * p2 is used to construct and argument which is a list of Tcl_Obj.
 * To call the function use z_tcl_call which automaticly handle error return
 * codes or z_command to call a Zinc command which handle all arguments too.
 */

/**
 * Call zinc->itemconfigure ( -closed )
 *
 * @param item the item to configure
 * @param value the closed to set
 */
void Zinc::itemSetClosed (ZincItem * item, bool value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_closed;
  p1[4] = Z_BOO_POOL (1, value);

  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetClosed Failed : ");
}

/**
 * Call zinc->itemcget ( -closed )
 *
 * @param item the item to get closed from
 * @return closed value
 */
bool Zinc::itemGetClosed (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_closed;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetClosed Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetBooleanFromObj (interp, tmp, &value),
              "itemGetClosed Failed : ");
  return bool (value);
}

/**
 * Call zinc->itemconfigure ( -composealpha )
 *
 * @param item the item to configure
 * @param value the composealpha to set
 */
void Zinc::itemSetComposealpha (ZincItem * item, bool value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_composealpha;
  p1[4] = Z_BOO_POOL (1, value);
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetComposealpha Failed : ");
}

/**
 * Call zinc->itemcget ( -composealpha )
 *
 * @param item the item to get composealpha from
 * @return composealpha value
 */
bool Zinc::itemGetComposealpha (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_composealpha;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetComposealpha Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetBooleanFromObj (interp, tmp, &value),
              "itemGetComposealpha Failed : ");
  return bool (value);
}

/**
 * Call zinc->itemconfigure ( -composerotation )
 *
 * @param item the item to configure
 * @param value the composerotation to set
 */
void Zinc::itemSetComposerotation (ZincItem * item, bool value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_composerotation;
  p1[4] = Z_BOO_POOL (1, value);
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetComposerotation Failed : ");
}

/**
 * Call zinc->itemcget ( -composerotation )
 *
 * @param item the item to get composerotation from
 * @return composerotation value
 */
bool Zinc::itemGetComposerotation (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_composerotation;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetComposerotation Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetBooleanFromObj (interp, tmp, &value),
              "itemGetComposerotation Failed : ");
  return (bool)value;
}

/**
 * Call zinc->itemconfigure ( -composescale )
 *
 * @param item the item to configure
 * @param value the composescale to set
 */
void Zinc::itemSetComposescale (ZincItem * item, bool value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_composescale;
  p1[4] = Z_BOO_POOL (1, value);
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetComposescale Failed : ");
}

/**
 * Call zinc->itemcget ( -composescale )
 *
 * @param item the item to get composescale from
 * @return composescale value
 */
bool Zinc::itemGetComposescale (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_composescale;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetComposescale Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetBooleanFromObj (interp, tmp, &value),
              "itemGetComposescale Failed : ");
  return (bool)value;
}

/**
 * Call zinc->itemconfigure ( -extent )
 *
 * @param item the item to configure
 * @param value the extent to set
 */
void Zinc::itemSetExtent (ZincItem * item, unsigned int value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_extent;
  p1[4] = Z_INT_POOL (1, value);
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetExtent Failed : ");
}

/**
 * Call zinc->itemcget ( -extent )
 *
 * @param item the item to get extent from
 * @return extent value
 */
unsigned int Zinc::itemGetExtent (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_extent;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetExtent Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetIntFromObj (interp, tmp, &value),
              "itemGetExtent Failed : ");
  return (unsigned int)value;
}

/**
 * Call zinc->itemconfigure ( -fillcolor )
 *
 * @param item the item to configure
 * @param value the fillcolor to set
 */
void Zinc::itemSetFillcolor (ZincItem * item, String value)
{
  //Warning, weird bug workaround
  // here is a deep copy
  // without this, on frequent calls, tcl mays segfault
  String tmp = String(value.c_str ());

  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_fillcolor;
  p1[4] = Z_STR_POOL (1, tmp.c_str (), -1);
  //call the zinc function in with 5 arguments internal form
  z_command (5, "itemSetFillcolor Failed : ");
}

/**
 * Call zinc->itemcget ( -fillcolor )
 *
 * @param item the item to get fillcolor from
 * @return fillcolor value
 */
String Zinc::itemGetFillcolor (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_fillcolor;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetFillcolor Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  return String (Tcl_GetStringFromObj (tmp, NULL));
}

/**
 * Call zinc->itemconfigure ( -filled )
 *
 * @param item the item to configure
 * @param value the filled to set
 */
void Zinc::itemSetFilled (ZincItem * item, bool value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_filled;
  p1[4] = Z_BOO_POOL (1, value);
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetFilled Failed : ");
}

/**
 * Call zinc->itemcget ( -filled )
 *
 * @param item the item to get filled from
 * @return filled value
 */
bool Zinc::itemGetFilled (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_filled;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetFilled Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetBooleanFromObj (interp, tmp, &value),
              "itemGetFilled Failed : ");
  return (bool)value;
}

/**
 * Call zinc->itemconfigure ( -fillpattern )
 *
 * @param item the item to configure
 * @param value the fillpattern to set
 */
void Zinc::itemSetFillpattern (ZincItem * item, ZincBitmap *value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_fillpattern;
  p1[4] = value->object;
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetFillpattern Failed : ");
}

/**
 * Call zinc->itemcget ( -fillpattern )
 *
 * @param item the item to get fillpattern from
 * @return fillpattern value
 */
ZincBitmap * Zinc::itemGetFillpattern (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_fillpattern;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetFillpattern Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  return new ZincBitmap (tmp, true);
}

/**
 * Call zinc->itemconfigure ( -linecolor )
 *
 * @param item the item to configure
 * @param value the linecolor to set
 */
void Zinc::itemSetLinecolor (ZincItem * item, String value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_linecolor;
  p1[4] = Z_STR_POOL (1, value.c_str (), value.length ());
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetLinecolor Failed : ");
}

/**
 * Call zinc->itemcget ( -linecolor )
 *
 * @param item the item to get linecolor from
 * @return linecolor value
 */
String Zinc::itemGetLinecolor (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_linecolor;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetLinecolor Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  return String (Tcl_GetStringFromObj (tmp, NULL));
}

/**
 * Call zinc->itemconfigure ( -linepattern )
 *
 * @param item the item to configure
 * @param value the linepattern to set
 */
void Zinc::itemSetLinepattern (ZincItem * item, ZincBitmap * value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_linepattern;
  p1[4] = value->object;
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetLinepattern Failed : ");
}

/**
 * Call zinc->itemcget ( -linepattern )
 *
 * @param item the item to get linepattern from
 * @return linepattern value
 */
ZincBitmap * Zinc::itemGetLinepattern (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_linepattern;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetLinepattern Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  return new ZincBitmap (tmp, true);
}

/**
 * Call zinc->itemconfigure ( -linestyle )
 *
 * @param item the item to configure
 * @param value the linestyle to set
 */
void Zinc::itemSetLinestyle (ZincItem * item, lineStyle value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_linestyle;
  p1[4] = lineStyles[value];
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetLinestyle Failed : ");
}

/**
 * Call zinc->itemcget ( -linestyle )
 *
 * @param item the item to get linestyle from
 * @return linestyle value
 */
lineStyle Zinc::itemGetLinestyle (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_linestyle;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetLinestyle Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetIndexFromObj (interp, tmp,
                                   lineStylesStrings, 
                                   "lineStyles",
                                   0, &value),
              "itemGetLinestyle Failed : ");
  return (lineStyle)value;
}

/**
 * Call zinc->itemconfigure ( -linewidth )
 *
 * @param item the item to configure
 * @param value the linewidth to set
 */
void Zinc::itemSetLinewidth (ZincItem * item, double value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_linewidth;
  p1[4] = Z_DBL_POOL (1, value);
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetLinewidth Failed : ");
}

/**
 * Call zinc->itemcget ( -linewidth )
 *
 * @param item the item to get linewidth from
 * @return linewidth value
 */
double Zinc::itemGetLinewidth (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_linewidth;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetLinewidth Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  double value;
  z_tcl_call (Tcl_GetDoubleFromObj (interp, tmp, &value),
              "itemGetLinewidth Failed : ");
  return (double)value;
}

/**
 * Call zinc->itemconfigure ( -pieslice )
 *
 * @param item the item to configure
 * @param value the pieslice to set
 */
void Zinc::itemSetPieslice (ZincItem * item, bool value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_pieslice;
  p1[4] = Z_BOO_POOL (1, value);
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetPieslice Failed : ");
}

/**
 * Call zinc->itemcget ( -pieslice )
 *
 * @param item the item to get pieslice from
 * @return pieslice value
 */
bool Zinc::itemGetPieslice (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_pieslice;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetPieslice Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetBooleanFromObj (interp, tmp, &value),
              "itemGetPieslice Failed : ");
  return (bool)value;
}

/**
 * Call zinc->itemconfigure ( -priority )
 *
 * @param item the item to configure
 * @param value the priority to set
 */
void Zinc::itemSetPriority (ZincItem * item, unsigned int value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_priority;
  p1[4] = Z_INT_POOL (1, value);
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetPriority Failed : ");
}

/**
 * Call zinc->itemcget ( -priority )
 *
 * @param item the item to get priority from
 * @return priority value
 */
unsigned int Zinc::itemGetPriority (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_priority;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetPriority Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetIntFromObj (interp, tmp, &value),
              "itemGetPriority Failed : ");
  return (unsigned int)value;
}

/**
 * Call zinc->itemconfigure ( -sensitive )
 *
 * @param item the item to configure
 * @param value the sensitive to set
 */
void Zinc::itemSetSensitive (ZincItem * item, bool value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_sensitive;
  p1[4] = Z_BOO_POOL (1, value);
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetSensitive Failed : ");
}

/**
 * Call zinc->itemcget ( -sensitive )
 *
 * @param item the item to get sensitive from
 * @return sensitive value
 */
bool Zinc::itemGetSensitive (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_sensitive;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetSensitive Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetBooleanFromObj (interp, tmp, &value),
              "itemGetSensitive Failed : ");
  return (bool)value;
}

/**
 * Call zinc->itemconfigure ( -startangle )
 *
 * @param item the item to configure
 * @param value the startangle to set
 */
void Zinc::itemSetStartangle (ZincItem * item, unsigned int value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_startangle;
  p1[4] = Z_INT_POOL (1, value);
  //call the zinc function  with 5 argumentsin internal form
  z_command (5, "itemSetStartangle Failed : ");
}

/**
 * Call zinc->itemcget ( -startangle )
 *
 * @param item the item to get startangle from
 * @return startangle value
 */
unsigned int Zinc::itemGetStartangle (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_startangle;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetStartangle Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetIntFromObj (interp, tmp, &value),
              "itemGetStartangle Failed : ");
  return (unsigned int)value;
}

/**
 * Call zinc->itemconfigure ( -tile )
 *
 * @param item the item to configure
 * @param value the tile to set
 */
void Zinc::itemSetTile (ZincItem * item, ZincBitmap * value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_tile;
  p1[4] = value->object;
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetTile Failed : ");
}

/**
 * Call zinc->itemcget ( -tile )
 *
 * @param item the item to get tile from
 * @return tile value
 */
ZincBitmap * Zinc::itemGetTile (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_tile;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetTile Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  return new ZincBitmap (tmp, true);
}

/**
 * Call zinc->itemconfigure ( -visible )
 *
 * @param item the item to configure
 * @param value the visible to set
 */
void Zinc::itemSetVisible (ZincItem * item, bool value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_visible;
  p1[4] = Z_BOO_POOL (1, value);
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetVisible Failed : ");
}

/**
 * Call zinc->itemcget ( -visible )
 *
 * @param item the item to get visible from
 * @return visible value
 */
bool Zinc::itemGetVisible (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_visible;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetVisible Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetBooleanFromObj (interp, tmp, &value),
              "itemGetVisible Failed : ");
  return (bool)value;
}

/**
 * Call zinc->itemconfigure ( -capstyle )
 *
 * @param item the item to configure
 * @param value the capstyle to set
 */
void Zinc::itemSetCapstyle (ZincItem * item, capStyle value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_capstyle;
  p1[4] = capStyles[value];
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetCapstyle Failed : ");
}

/**
 * Call zinc->itemcget ( -capstyle )
 *
 * @param item the item to get capstyle from
 * @return capstyle value
 */
capStyle Zinc::itemGetCapstyle (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_capstyle;
  //call the zinc function  with 4 argumentsin internal form
  z_command (4, "itemGetCapstyle Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetIndexFromObj (interp, tmp,
                                   capStylesStrings, 
                                   "capStyles",
                                   0, &value),
              "itemGetCapstyle Failed : ");
  return (capStyle)value;
}

/**
 * Call zinc->itemconfigure ( -fillrule )
 *
 * @param item the item to configure
 * @param value the fillrule to set
 */
void Zinc::itemSetFillrule (ZincItem * item, fillRule value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_fillrule;
  p1[4] = fillRules[value];
  //call the zinc function  with 5 argumentsin internal form
  z_command (5, "itemSetFillrule Failed : ");
}

/**
 * Call zinc->itemcget ( -fillrule )
 *
 * @param item the item to get fillrule from
 * @return fillrule value
 */
fillRule Zinc::itemGetFillrule (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_fillrule;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetFillrule Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetIndexFromObj (interp, tmp,
                                   fillRulesStrings, 
                                   "fillRules",
                                   0, &value),
              "itemGetFillrule Failed : ");
  return (fillRule)value;
}

/**
 * Call zinc->itemconfigure ( -joinstyle )
 *
 * @param item the item to configure
 * @param value the joinstyle to set
 */
void Zinc::itemSetJoinstyle (ZincItem * item, joinStyle value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_joinstyle;
  p1[4] = joinStyles[value];
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetJoinstyle Failed : ");
}

/**
 * Call zinc->itemcget ( -joinstyle )
 *
 * @param item the item to get joinstyle from
 * @return joinstyle value
 */
joinStyle Zinc::itemGetJoinstyle (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_joinstyle;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetJoinstyle Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetIndexFromObj (interp, tmp,
                                   joinStylesStrings, 
                                   "joinStyles",
                                   0, &value),
              "itemGetJoinstyle Failed : ");
  return (joinStyle)value;
}

/**
 * Call zinc->itemconfigure ( -relief )
 *
 * @param item the item to configure
 * @param value the relief to set
 */
void Zinc::itemSetRelief (ZincItem * item, relief value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_relief;
  p1[4] = reliefs[value];
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetRelief Failed : ");
}

/**
 * Call zinc->itemcget ( -relief )
 *
 * @param item the item to get relief from
 * @return relief value
 */
relief Zinc::itemGetRelief (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_relief;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetRelief Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetIndexFromObj (interp, tmp,
                                   reliefsStrings, 
                                   "reliefs",
                                   0, &value),
              "itemGetRelief Failed : ");
  return (relief)value;
}

/**
 * Call zinc->itemconfigure ( -smoothrelief )
 *
 * @param item the item to configure
 * @param value the smoothrelief to set
 */
void Zinc::itemSetSmoothrelief (ZincItem * item, bool value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_smoothrelief;
  p1[4] = Z_BOO_POOL (1, value);
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetSmoothrelief Failed : ");
}

/**
 * Call zinc->itemcget ( -smoothrelief )
 *
 * @param item the item to get smoothrelief from
 * @return smoothrelief value
 */
bool Zinc::itemGetSmoothrelief (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_smoothrelief;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetSmoothrelief Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetBooleanFromObj (interp, tmp, &value),
              "itemGetSmoothrelief Failed : ");
  return (bool)value;
}

/**
 * Call zinc->itemconfigure ( -alpha )
 *
 * @param item the item to configure
 * @param value the alpha to set
 */
void Zinc::itemSetAlpha (ZincItem * item, unsigned int value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_alpha;
  p1[4] = Z_INT_POOL (1, value);
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetAlpha Failed : ");
}

/**
 * Call zinc->itemcget ( -alpha )
 *
 * @param item the item to get alpha from
 * @return alpha value
 */
unsigned int Zinc::itemGetAlpha (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_alpha;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetAlpha Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetIntFromObj (interp, tmp, &value),
              "itemGetAlpha Failed : ");
  return (unsigned int)value;
}

/**
 * Call zinc->itemconfigure ( -atomic )
 *
 * @param item the item to configure
 * @param value the atomic to set
 */
void Zinc::itemSetAtomic (ZincItem * item, bool value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_atomic;
  p1[4] = Z_BOO_POOL (1, value);
  //call the zinc function in with 5 arguments internal form
  z_command (5, "itemSetAtomic Failed : ");
}

/**
 * Call zinc->itemcget ( -atomic )
 *
 * @param item the item to get atomic from
 * @return atomic value
 */
bool Zinc::itemGetAtomic (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_atomic;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetAtomic Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetBooleanFromObj (interp, tmp, &value),
              "itemGetAtomic Failed : ");
  return (bool)value;
}

/**
 * Call zinc->itemconfigure ( -clip )
 *
 * @param item the item to configure
 * @param value the clip to set
 */
void Zinc::itemSetClip (ZincItem * item, ZincItem * value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_clip;
  p1[4] = value->object;
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetClip Failed : ");
}

/**
 * Call zinc->itemcget ( -clip )
 *
 * @param item the item to get clip from
 * @return clip value
 */
ZincItem * Zinc::itemGetClip (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_clip;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetClip Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  return new ZincItem(tmp);
}

/**
 * Call zinc->itemconfigure ( -anchor )
 *
 * @param item the item to configure
 * @param value the anchor to set
 */
void Zinc::itemSetAnchor (ZincItem * item, anchor value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_anchor;
  p1[4] = anchors[value];
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetAnchor Failed : ");
}

/**
 * Call zinc->itemcget ( -anchor )
 *
 * @param item the item to get anchor from
 * @return anchor value
 */
anchor Zinc::itemGetAnchor (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_anchor;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetAnchor Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetIndexFromObj (interp, tmp,
                                   anchorsStrings, 
                                   "anchors",
                                   0, &value),
              "itemGetAnchor Failed : ");
  return (anchor)value;
}

/**
 * Call zinc->itemconfigure ( -color )
 *
 * @param item the item to configure
 * @param value the color to set
 */
void Zinc::itemSetColor (ZincItem * item, String value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_color;
  p1[4] = Z_STR_POOL (1, value.c_str (), value.length ());
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetColor Failed : ");
}

/**
 * Call zinc->itemcget ( -color )
 *
 * @param item the item to get color from
 * @return color value
 */
String Zinc::itemGetColor (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_color;
  //call the zinc function with 4 argument in internal form
  z_command (4, "itemGetColor Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  return String (Tcl_GetStringFromObj (tmp, NULL));
}

/**
 * Call zinc->itemconfigure ( -connecteditem )
 *
 * @param item the item to configure
 * @param value the connecteditem to set
 */
void Zinc::itemSetConnecteditem (ZincItem * item, ZincItem * value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_connecteditem;
  p1[4] = value->object;
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetConnecteditem Failed : ");
}

/**
 * Call zinc->itemcget ( -connecteditem )
 *
 * @param item the item to get connecteditem from
 * @return connecteditem value
 */
ZincItem * Zinc::itemGetConnecteditem (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_connecteditem;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetConnecteditem Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  return new ZincItem(tmp);
}

/**
 * Call zinc->itemconfigure ( -connectionanchor )
 *
 * @param item the item to configure
 * @param value the connectionanchor to set
 */
void Zinc::itemSetConnectionanchor (ZincItem * item, anchor value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_connectionanchor;
  p1[4] = anchors[value];
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetConnectionanchor Failed : ");
}

/**
 * Call zinc->itemcget ( -connectionanchor )
 *
 * @param item the item to get connectionanchor from
 * @return connectionanchor value
 */
anchor Zinc::itemGetConnectionanchor (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_connectionanchor;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetConnectionanchor Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetIndexFromObj (interp, tmp,
                                   anchorsStrings, 
                                   "anchors",
                                   0, &value),
              "itemGetConnectionanchor Failed : ");
  return (anchor)value;
}

/**
 * Call zinc->itemconfigure ( -image )
 *
 * @param item the item to configure
 * @param value the image to set
 */
void Zinc::itemSetImage (ZincItem * item, ZincImage * value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_image;
  p1[4] = value->object;
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetImage Failed : ");
}

/**
 * Call zinc->itemcget ( -image )
 *
 * @param item the item to get image from
 * @return image value
 */
ZincImage * Zinc::itemGetImage (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_image;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetImage Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  return new ZincImage(tmp, true);
}

/**
 * Call zinc->itemconfigure ( -mask )
 *
 * @param item the item to configure
 * @param value the mask to set
 */
void Zinc::itemSetMask (ZincItem * item, ZincBitmap * value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_mask;
  p1[4] = value->object;
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetMask Failed : ");
}

/**
 * Call zinc->itemcget ( -mask )
 *
 * @param item the item to get mask from
 * @return mask value
 */
ZincBitmap * Zinc::itemGetMask (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_mask;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetMask Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  return new ZincBitmap (tmp, true);
}

/**
 * Call zinc->itemconfigure ( -alignment )
 *
 * @param item the item to configure
 * @param value the alignment to set
 */
void Zinc::itemSetAlignment (ZincItem * item, alignment value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_alignment;
  p1[4] = alignments[value];
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetAlignment Failed : ");
}

/**
 * Call zinc->itemcget ( -alignment )
 *
 * @param item the item to get alignment from
 * @return alignment value
 */
alignment Zinc::itemGetAlignment (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_alignment;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetAlignment Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetIndexFromObj (interp, tmp,
                                   alignmentsStrings, 
                                   "alignments",
                                   0, &value),
              "itemGetAlignment Failed : ");
  return (alignment)value;
}

/**
 * Call zinc->itemconfigure ( -font )
 *
 * @param item the item to configure
 * @param value the font to set
 */
void Zinc::itemSetFont (ZincItem * item, ZincFont * value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_font;
  p1[4] = Z_STR_POOL (0, value->name.c_str(), value->name.length());
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetFont Failed : ");
}

/**
 * Call zinc->itemcget ( -font )
 *
 * @param item the item to get font from
 * @return font value
 */
ZincFont * Zinc::itemGetFont (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_font;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetFont Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  return new ZincFont (Tcl_GetStringResult (interp));
}

/**
 * Call zinc->itemconfigure ( -overstriked )
 *
 * @param item the item to configure
 * @param value the overstriked to set
 */
void Zinc::itemSetOverstriked (ZincItem * item, bool value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_overstriked;
  p1[4] = Z_BOO_POOL (1, value);
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetOverstriked Failed : ");
}

/**
 * Call zinc->itemcget ( -overstriked )
 *
 * @param item the item to get overstriked from
 * @return overstriked value
 */
bool Zinc::itemGetOverstriked (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_overstriked;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetOverstriked Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetBooleanFromObj (interp, tmp, &value),
              "itemGetOverstriked Failed : ");
  return (bool)value;
}

/**
 * Call zinc->itemconfigure ( -spacing )
 *
 * @param item the item to configure
 * @param value the spacing to set
 */
void Zinc::itemSetSpacing (ZincItem * item, short value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_spacing;
  p1[4] = Z_INT_POOL (1, value);
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetSpacing Failed : ");
}

/**
 * Call zinc->itemcget ( -spacing )
 *
 * @param item the item to get spacing from
 * @return spacing value
 */
short Zinc::itemGetSpacing (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_spacing;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetSpacing Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetIntFromObj (interp, tmp, &value),
              "itemGetSpacing Failed : ");
  return (short)value;
}

/**
 * Call zinc->itemconfigure ( -text )
 *
 * @param item the item to configure
 * @param value the text to set
 */
void Zinc::itemSetText (ZincItem * item, String value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_text;
  p1[4] = Z_STR_POOL (1, value.c_str (), value.length ());
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetText Failed : ");
}

/**
 * Call zinc->itemcget ( -text )
 *
 * @param item the item to get text from
 * @return text value
 */
String Zinc::itemGetText (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_text;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetText Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  return String (Tcl_GetStringFromObj (tmp, NULL));
}

/**
 * Call zinc->itemconfigure ( -underlined )
 *
 * @param item the item to configure
 * @param value the underlined to set
 */
void Zinc::itemSetUnderlined (ZincItem * item, bool value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_underlined;
  p1[4] = Z_BOO_POOL (1, value);
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetUnderlined Failed : ");
}

/**
 * Call zinc->itemcget ( -underlined )
 *
 * @param item the item to get underlined from
 * @return underlined value
 */
bool Zinc::itemGetUnderlined (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_underlined;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetUnderlined Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetBooleanFromObj (interp, tmp, &value),
              "itemGetUnderlined Failed : ");
  return (bool)value;
}

/**
 * Call zinc->itemconfigure ( -width )
 *
 * @param item the item to configure
 * @param value the width to set
 */
void Zinc::itemSetWidth (ZincItem * item, unsigned short value)
{
  //prepare arguments : .zinc itemconfigure item attribute value
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_width;
  p1[4] = Z_INT_POOL (1, value);
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetWidth Failed : ");
}

/**
 * Call zinc->itemcget ( -width )
 *
 * @param item the item to get width from
 * @return width value
 */
unsigned short Zinc::itemGetWidth (ZincItem * item)
{
  Tcl_Obj* tmp;
  //discard all old results
  Tcl_ResetResult (interp);
  //prepare arguments : .zinc itemcget item 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_width;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetWidth Failed : ");

  //retreive the result trough the tcl interpreter and convert it
  tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetIntFromObj (interp, tmp, &value),
              "itemGetWidth Failed : ");
  return (unsigned short)value;
}



/*******************************************************
             END OF AUTOGENERATED METHODS
*******************************************************/


/**
 * How To call Zinc or Tcl functions:
 *
 * All arguments of the function are Tcl_Obj. To accelerate their call, there
 * is a pool of preconstructed Tcl_Obj and some often used constant Tcl_Obj.
 * p1 and p2 are tables of pointers to be used for arguments.
 * Fill p1 using either predefined objects like ZITM_* or a pool objet that
 * you can fill with the value you want.
 *  Ex : p1[1] = ZFCT_add;
 * Macros have been defined to fill and use a pool object
 *  Ex : p1[2] = Z_INT_POOL(1, 200);
 * Do not use twice the same pool index for the same function call.
 * p2 is used to construct and argument which is a list of Tcl_Obj.
 * To call the function use z_tcl_call which automaticly handle error return
 * codes or z_command to call a Zinc command which handle all arguments too.
 */
/**
 * Call zinc->itemconfigure ( -firstend )
 *
 * @param item the item to get width from
 * @param a,b,c values used to set end
 */
void Zinc::itemSetFirstend (ZincItem * item, double a, double b, double c)
{
  String value = dtos (a) + " " + dtos (b) + " " + dtos (c);
  // call .zinc itemconfigure item -firstend "a b c"
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_firstend;
  p1[4] = Z_STR_POOL (1, value.c_str (), value.length ());
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetFirstend Failed : ");
}
  
  
/**
 * Call zinc->itemcget ( -firstend )
 *
 * @param item the item to get width from
 * @param a,b,c values used to sedwhere we'll put end
 */
void Zinc::itemGetFirstend (ZincItem * item, double *a, double *b, double *c)
{
  Tcl_Obj *tmp;
  int argc;
  char * line;

  //discard old results
  Tcl_ResetResult (interp);
  // call .zinc itemcget item -firstend
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_firstend;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetFirstend Failed : ");

  //get the result as a string
  tmp = Tcl_GetObjResult (interp);
  line = Tcl_GetStringFromObj (tmp, NULL);

  //interpret the string a 3 double
  argc = sscanf(line, "%lf %lf %lf", a, b, c);
  if (argc != 3)
  {
    throw ZincException (String("itemGetFirstend Failed"), __FILE__, __LINE__);
  }
}

/**
 * Call zinc->itemconfigure ( -lastend )
 *
 * @param item the item to get width from
 * @param a,b,c values used to set end
 */
void Zinc::itemSetLastend (ZincItem * item, double a, double b, double c)
{
  String value = dtos (a) + " " + dtos (b) + " " + dtos (c);
  // call .zinc itemconfigure item -lastend "a b c"
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_lastend;
  p1[4] = Z_STR_POOL (1, value.c_str (), value.length ());
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetLastend Failed : ");
}

/**
 * Call zinc->itemcget ( -lastend )
 *
 * @param item the item to get width from
 * @param a,b,c values used to sedwhere we'll put end
 */
void Zinc::itemGetLastend (ZincItem * item, double *a, double *b, double *c)
{
  Tcl_Obj *tmp;
  int argc;
  char * line;

  //discard old results
  Tcl_ResetResult (interp);
  // call .zinc itemcget item -lastend
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_lastend;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetLastend Failed : ");

  //get the result as a string
  tmp = Tcl_GetObjResult (interp);
  line = Tcl_GetStringFromObj (tmp, NULL);

  //interpret the string a 3 double
  argc = sscanf(line, "%lf %lf %lf", a, b, c);
  if (argc != 3)
  {
    throw ZincException (String("itemGetLastend Failed"), __FILE__, __LINE__);
  }
}

/**
 * Call zinc->itemconfigure ( -position )
 *
 * @param item the item to get width fromset position to
 * @param x,y position
 */
void Zinc::itemSetPosition (ZincItem * item, double x, double y)
{
  // call .zinc itemconfigure item -position {x y}
  p1[0] = id;
  p1[1] = ZFCT_itemconfigure;
  p1[2] = item->object;
  p1[3] = ZOPT_position;
  //make a pair
   p2[0] = Z_DBL_POOL (1, x);
   p2[1] = Z_DBL_POOL (2, y);
  p1[4] = Z_LST_POOL (3, p2, 2); // a list of 2 items
  //call the zinc function with 5 arguments in internal form
  z_command (5, "itemSetPosition Failed : ");
  // clean the list No 3 in the pool
  Z_CLEANLIST (3);
}

/**
 * Call zinc->itemcget ( -position )
 *
 * @param item the item to get position from
 * @param x,y position
 */
void Zinc::itemGetPosition (ZincItem * item, double *x, double *y)
{
  Tcl_Obj *tmp;
  int num;
  Tcl_Obj** elems;

  //discard old results
  Tcl_ResetResult (interp);
  // call .zinc itemcget item -position 
  p1[0] = id;
  p1[1] = ZFCT_itemcget;
  p1[2] = item->object;
  p1[3] = ZOPT_position;
  //call the zinc function with 4 arguments in internal form
  z_command (4, "itemGetPosition Failed : ");

  //retreive the result as a list
  tmp = Tcl_GetObjResult (interp);
  z_tcl_call (Tcl_ListObjGetElements (interp, tmp, &num, &elems),
              "itemGetPosition Failed : ");

  //num is necessarily 2 extract 2 double
  z_tcl_call (Tcl_GetDoubleFromObj(interp, elems[0], x),
              "itemGetPosition Failed : ");
  z_tcl_call (Tcl_GetDoubleFromObj(interp, elems[0], y),
              "itemGetPosition Failed : ");
}

/**
 * Create an image object
 *
 * @param the image reference (a file name)
 * @param isPhoto true for a picture, false for an X11 bitmap
 */
ZincImage* Zinc::createImageFromFile (String image)
{
  const char* para[5];
  //discard old results
  Tcl_ResetResult (interp);
  // prepare arguments to call : image create (photo|bitmap) -file image
  para[0] = "image";
  para[1] = "create";
  para[2] = "photo";
  para[3] = "-file";
  para[4] = image.c_str ();

  // call the function with 5 arguments and check for error
  z_tcl_call ((*imgCmdInfo.proc)(imgCmdInfo.clientData, interp, 5, para),
              "createImageFromFile Failed : ");
  return new ZincImage (Tcl_GetObjResult (interp));  
}

/**
 * Create an image object
 *
 * @param the image reference (a base64 String or binary data)
 * @param isPhoto true for a picture, false for an X11 bitmap
 */
ZincImage* Zinc::createImageFromData (String image)
{
  const char* para[5];
  //discard old results
  Tcl_ResetResult (interp);
  // prepare arguments to call : image create (photo|bitmap) -data image
  para[0] = "image";
  para[1] = "create";
  para[2] = "photo";
  para[3] = "-data";
  para[4] = image.c_str ();

  // call the function with 5 arguments and check for error
  z_tcl_call ((*imgCmdInfo.proc)(imgCmdInfo.clientData, interp, 5, para),
              "createImageFromData Failed : ");
  return new ZincImage (Tcl_GetObjResult (interp));
}

/**
 * Create a bitmap object from a file
 *
 * @param image the bitmap reference (a file name)
 */
ZincBitmap* Zinc::createBitmapFromFile (String image)
{
  const char* para[5];
  //discard old results
  Tcl_ResetResult (interp);
  // prepare arguments to call : image create (photo|bitmap) -file image
  para[0] = "image";
  para[1] = "create";
  para[2] = "bitmap";
  para[3] = "-file";
  para[4] = image.c_str ();

  // call the function with 5 arguments and check for error
  z_tcl_call ((*imgCmdInfo.proc)(imgCmdInfo.clientData, interp, 5, para),
              "createBitmapFromFile Failed : ");
  return new ZincBitmap (Tcl_GetObjResult (interp), false);  
}

/**
 * Create a bitmap object base64 data
 *
 * @param image the bitmap reference (a base64 String or binary data)
 */
ZincBitmap* Zinc::createBitmapFromData (String image)
{
  const char* para[5];
  //discard old results
  Tcl_ResetResult (interp);
  // prepare arguments to call : image create (photo|bitmap) -data image
  para[0] = "image";
  para[1] = "create";
  para[2] = "bitmap";
  para[3] = "-data";
  para[4] = image.c_str ();

  // call the function with 5 arguments and check for error
  z_tcl_call ((*imgCmdInfo.proc)(imgCmdInfo.clientData, interp, 5, para),
              "createBitmapFromData Failed : ");
  return new ZincBitmap (Tcl_GetObjResult (interp), false);
}

/**
 * Create a bitmap object using a predefined name
 *
 * @param image the bitmap reference (a name)
 */
ZincBitmap* Zinc::createBitmapFromName (String image)
{
  return new ZincBitmap (image);
}

/**
 * Create an image object
 *
 * @param width Width of image
 * @param height Height of image
 * @param aggBuffer An AGG buffer
 */
ZincImage* Zinc::createImageFromAGGBuffer (int width, int height, unsigned char *aggBuffer)
{
  const char* para[7];
  //discard old results
  Tcl_ResetResult (interp);

  // create a blank offscreen image
  para[0] = "image";
  para[1] = "create";
  para[2] = "photo";
  para[3] = "-height";
  para[4] =  String(itos (height).c_str ()).c_str ();
  para[5] = "-width";
  para[6] =  String(itos (width).c_str ()).c_str ();
  
  // call the function with 7 arguments and check for error
  z_tcl_call ((*imgCmdInfo.proc)(imgCmdInfo.clientData, interp, 7, para),
              "createImageFromBuffer Failed : ");
  // save result
  ZincImage *result = new ZincImage (Tcl_GetObjResult (interp));
  
  // get tcl PhotoImage handle
  Tk_PhotoHandle photo;
  photo = Tk_FindPhoto (interp, Tcl_GetString (result->object));
  if (photo == NULL)
  {
    // todo: error
  }
  
  // create a PhotoImageBlock
  Tk_PhotoImageBlock block;
  block.pixelPtr = aggBuffer;
  block.width = width;
  block.height = height;
  block.pitch = block.width * 3;
  block.pixelSize = 3;
  block.offset[0] = 0;
  block.offset[1] = 1;
  block.offset[2] = 2;
  block.offset[3] = 0;
  
  /* copy block to photo image and leave the rest to tk */
  Tk_PhotoPutBlock(photo, &block, 0, 0, block.width, block.height, TK_PHOTO_COMPOSITE_SET);
  
  // return result
  return result;
}



/**
 * Create a font object
 *
 * @param family the font mamily
 * @param size if a positive number, it is in points, if a negative number,
 *   its absolute value is a size in pixels.
 * @param bold 1 for a bold font, 0 for a normal font, -1 for unspecified
 * @param italic 1 an italic font, 0 for a roman font, -1 for unspecified
 * @param underline 1 for an underlined, 0 for a normal font, -1 for
 *    unspecified
 * @param overstrike 1 for an overstriked font, 0 for a normal font, -1 for unspecified
 */
ZincFont* Zinc::createFont (String family, int size, int bold, int italic,
                            int underline, int overstrike)
{
  const char* para[14];
  //quote family to avoid problems with spaces

  //discard old results
  Tcl_ResetResult (interp);
  // prepare arguments to call : font create -family family -size size
  //   -weight weight -slant slant -underline underline -overstrike overstrike
  para[0] = "font";
  para[1] = "create";
  para[2] = "-family";
  para[3] = family.c_str ();
  para[4] = "-size";
  //Warning, weird bug workaround
  // here is a deep copy
  // without this, on one MDK10.1 machine tcl sees an empty string
  String tmp = String(itos (size).c_str ());
  para[5] = tmp.c_str ();

  // use i as a variable parameter pointer
  int i=6; // last parameter is para[5]
  //handle default value for weight
  if (bold != -1)
  {
    para[i++] = "-weight";
    para[i++] = bold == 1 ? "bold" : "normal";
  }
  //handle default value for italic
  if (italic != -1)
  {
    para[i++] = "-slant";
    para[i++] = italic == 1 ? "italic" : "roman";
  }
  //handle default value for underline
  if (underline != -1)
  {
    para[i++] = "-underline";
    para[i++] = underline == 1 ? "true" : "false";
  }
  //handle default value for overstrike
  if (overstrike != -1)
  {
    para[i++] = "-overstrike";
    para[i++] = overstrike == 1 ? "true" : "false";
  }

  // call the function with i arguments and check for error
  z_tcl_call ((*fntCmdInfo.proc)(fntCmdInfo.clientData, interp, i, para),
              "createFont Failed : ");
  return new ZincFont (Tcl_GetStringResult (interp));
}

/**
 * Get font ascent
 *
 * @param font the font
 * @return the font ascent
 */
int Zinc::getFontAscent (ZincFont* font)
{
  const char* para[4];

  //discard old results
  Tcl_ResetResult (interp);
  // prepare arguments to call : font metrics font -ascent
  para[0] = "font";
  para[1] = "metrics";
  para[2] = font->name.c_str();
  para[3] = "-ascent";

  // call the function with 4 arguments and check for error
  z_tcl_call ((*fntCmdInfo.proc)(fntCmdInfo.clientData, interp, 4, para),
              "getFontAscent Failed : ");

  //retreive the result as an integer
  Tcl_Obj *tmp = Tcl_GetObjResult (interp);
  int value;
  z_tcl_call (Tcl_GetIntFromObj (interp, tmp, &value),
              "getFontAscent Failed : ");
  return value;
}


/**
 * Get Image width
 *
 * @param ZincImage the image to get width from
 * @return the width of the image
 */
int Zinc::getImageWidth (ZincImage *image)
{
  const char* para[3];

  //discard old results
  Tcl_ResetResult (interp);
  // prepare arguments to call : image create (photo|bitmap) -data image
  para[0] = "image";
  para[1] = "width";
  para[2] = Tcl_GetString (image->object);

  // call the function with 3 arguments and check for error
  z_tcl_call ((*imgCmdInfo.proc)(imgCmdInfo.clientData, interp, 3, para),
              "getImageWidth Failed : ");

  int value;
  // retreive the result as an integer
  Tcl_Obj *tmp = Tcl_GetObjResult (interp);
  z_tcl_call (Tcl_GetIntFromObj (interp, tmp, &value),
              "getImageWidth Failed : ");
  return value;
}

/**
 * Get Image height
 *
 * @param ZincImage the image to get height from
 * @return the height of the image
 */
int Zinc::getImageHeight (ZincImage *image)
{
  const char* para[3];

  //discard old results
  Tcl_ResetResult (interp);
  // prepare arguments to call : image create (photo|bitmap) -data image
  para[0] = "image";
  para[1] = "height";
  para[2] = Tcl_GetString (image->object);

  // call the function with 3 arguments and check for error
  z_tcl_call ((*imgCmdInfo.proc)(imgCmdInfo.clientData, interp, 3, para),
              "getImageHeight Failed : ");

  int value;
  // retreive the result as an integer
  Tcl_Obj *tmp = Tcl_GetObjResult (interp);
  z_tcl_call (Tcl_GetIntFromObj (interp, tmp, &value),
              "getImageHeight Failed : ");
  return value;
}

/**
 * This is inline because it is called frequently and needs to be optimized
 * Use this when you need to call a function that can return a TCL error code.
 *
 * @param fct the full function call
 * @param msg the error message to throw in case of error
 */ 
void Zinc::z_tcl_call (int result, char* p_msg) throw (ZincException)
{
  if (result != TCL_OK)
  {
    const char *r;
    String msg = "zinclib: ";
    if (p_msg != NULL)
    {
      msg.append (p_msg);
    }
    r = Tcl_GetStringResult (interp);
    if (r != NULL)
    {
      msg.append (r);
    }
    throw ZincException (msg, __FILE__, __LINE__ );
  }
}

/**
 * This is a inline because it is called frequently and needs to be optimized
 * Use this to call the zinObjectCommand fuction. The call is made using the
 * pre allocated table p1, it must contain Tcl_Obj thar are parameters to
 * the zinObjectCommand function. A parameter indicate how many parameters
 * are passed to the zinObjectCommand function.
 *
 * @param count the number of parameters in p1
 * @param msg the error message to throw in case of error
 */ 
void Zinc::z_command (int count, char* p_msg) throw (ZincException)
{
  int result = (*objCmd) (wi, interp, (count), p1);
  if (result != TCL_OK)
  {
    const char *r;
    String msg = "zinclib: ";
    if (p_msg != NULL)
    {
      msg.append (p_msg);
    }
    r = Tcl_GetStringResult (interp);
    if (r != NULL)
    {
      msg.append (r);
    }
    throw ZincException (msg, __FILE__, __LINE__ );
  }
}
